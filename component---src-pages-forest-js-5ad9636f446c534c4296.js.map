{"version":3,"sources":["webpack:///./src/components/index-lead.js","webpack:///./src/pages/forest.js"],"names":["ImageIndexLead","src","data","fluid","placeholderImage","childImageSharp","IndexPage","className","path","title","frameBorder","to","width","height","config","options","roughness","points","stroke","x1","x2","y1","y2"],"mappings":"ygFAeaA,EAAiB,SAAC,GAAY,EAAVC,IAAW,IACpCC,EAAI,OAcV,OAAO,kBAAC,IAAD,CAAKC,MAAOD,EAAKE,iBAAiBC,gBAAgBF,S,wBCmI5CG,UAtJG,kBAChB,kBAAC,IAAD,CAAQC,UAAU,cAAcC,KAAK,UACnC,kBAAC,IAAD,CAAKC,MAAM,kCACX,yBAAKF,UAAU,QACb,kBAAC,EAAD,MACA,mCACA,uFAEF,iCACE,4BACEA,UAAU,cACVG,YAAY,IACZT,IAAI,6BAEN,yQAMA,oRAImD,IACjD,kBAAC,OAAD,CAAMU,GAAG,uCAAT,qBALF,oKAQoB,IAClB,kBAAC,OAAD,CAAMA,GAAG,gDAAT,kCATF,mHAa4C,IAC1C,kBAAC,OAAD,CAAMA,GAAG,mFAAT,eAdF,KAmBA,6CACA,iFACsD,IACpD,iDAFF,kEAKA,0GAGE,4BACE,gCACG,kCADH,qCAGA,gCACG,kCADH,6CAGA,gCACG,kCADH,0DAGA,gCACG,kCADH,gCAGA,gCACG,kCADH,oDAhBJ,wDAoBuD,kCApBvD,kIAuBE,4BACE,8CACA,+CACA,kDAGJ,kTAIuE,IACrE,gDALF,wCAKiE,kBAAC,OAAD,CAAMA,GAAG,gBAAT,eALjE,8BAQA,uBAAGJ,UAAU,UACX,yBAAKN,IAAI,6BAEX,+JAE2D,IACzD,oDAHF,2DAIiB,uCAJjB,gIAQA,2CACA,4LAGkB,mCAHlB,6MAQA,qZAM8B,kCAN9B,iFAOuD,IACrD,uDARF,yBAUA,yBAAKM,UAAU,WACb,uBAAGA,UAAU,UACX,yBAAKN,IAAI,kCAEX,kBAAC,IAAD,CACEW,MAAO,IACPC,OAAQ,IACRC,OAAQ,CACNC,QAAS,CACPC,UAAW,KAIf,kBAAC,IAAD,CACEC,OAAQ,CACN,CAAC,GAAI,GACL,CAAC,IAAK,IACN,CAAC,GAAI,KACL,CAAC,GAAI,MAEPC,OAAO,QAET,kBAAC,IAAD,CAAMC,GAAI,GAAIC,GAAI,GAAIC,GAAI,IAAKC,GAAI,IAAKJ,OAAO,QAC/C,kBAAC,IAAD,CAAMC,GAAI,GAAIC,GAAI,GAAIC,GAAI,IAAKC,GAAI,IAAKJ,OAAO,SAEjD,uBAAGX,UAAU,UACX,yBAAKN,IAAI,8BAGb,iEACA,uBAAGM,UAAU,QAAb,eAGA,kBAAC,IAAD","file":"component---src-pages-forest-js-5ad9636f446c534c4296.js","sourcesContent":["import React from \"react\"\r\nimport { useStaticQuery, graphql } from \"gatsby\"\r\nimport Img from \"gatsby-image\"\r\n\r\n/*\r\n * This component is built using `gatsby-image` to automatically serve optimized\r\n * images with lazy loading and reduced file sizes. The image is loaded using a\r\n * `useStaticQuery`, which allows us to load the image from directly within this\r\n * component, rather than having to pass the image data down from pages.\r\n *\r\n * For more information, see the docs:\r\n * - `gatsby-image`: https://gatsby.dev/gatsby-image\r\n * - `useStaticQuery`: https://www.gatsbyjs.org/docs/use-static-query/\r\n */\r\n\r\nexport const ImageIndexLead = ({ src }) => {\r\n  const data = useStaticQuery(graphql`\r\n    query {\r\n      placeholderImage: file(\r\n        relativePath: { eq: \"les-krasivye-kartinki-na-rabochij-stol-2.jpg\" }\r\n      ) {\r\n        childImageSharp {\r\n          fluid(maxWidth: 1920) {\r\n            ...GatsbyImageSharpFluid\r\n          }\r\n        }\r\n      }\r\n    }\r\n  `)\r\n\r\n  return <Img fluid={data.placeholderImage.childImageSharp.fluid} />\r\n}\r\n","import React from \"react\"\r\nimport { Link } from \"gatsby\"\r\nimport ReactRough, { Curve, Line } from \"react-rough\"\r\n\r\nimport Layout from \"../components/layout\"\r\nimport SEO from \"../components/seo\"\r\nimport { ImageIndexLead } from \"../components/index-lead\"\r\n\r\nimport \"./forest.css\"\r\nimport { Footer } from \"../components/footer\"\r\n\r\nconst IndexPage = () => (\r\n  <Layout className=\"forest-page\" path=\"forest\">\r\n    <SEO title=\"О процедурной генерации лесов\" />\r\n    <div className=\"lead\">\r\n      <ImageIndexLead />\r\n      <h1>Лес</h1>\r\n      <summary>Это история о том, как вырастить лес. В браузере.</summary>\r\n    </div>\r\n    <article>\r\n      <iframe\r\n        className=\"tree-on-box\"\r\n        frameBorder=\"0\"\r\n        src=\"/tree-on-cube/index.html\"\r\n      />\r\n      <p>\r\n        Предположим, вы хотите создать игру, действие которой происходит в лесу.\r\n        Или же просто игру, в которой есть лесной массив. Как это сделать? Самый\r\n        дешевый способ - сгенерировать случайное распределение деревьев по\r\n        заданной поверхности.\r\n      </p>\r\n      <p>\r\n        Однажды, когда я был за городом, я много времени провел в лесу и мне не\r\n        давала покоя мысль: как сымитировать его случайность? В лесу все\r\n        хаотично, но при этом взаимосвязано. Тогда я провел небольше\r\n        исследование и нашел отличную статью Уэсли Керра{\" \"}\r\n        <Link to=\"https://www.wesley-kerr.com/forest/\">о генерации лесов</Link>.\r\n        Я не буду делать перевод этой статьи, однако, она довольно простая и\r\n        интересная, и она точно стоит того, чтобы ознакомиться. Или, например, с\r\n        этими работами по{\" \"}\r\n        <Link to=\"http://pcg.wikidot.com/pcg-algorithm:forests\">\r\n          процедурной генерации растений\r\n        </Link>\r\n        . Основываясь на этой работе я сделал порт кода в javascript и вот что\r\n        из этого вышло. Результат можно увидеть в{\" \"}\r\n        <Link to=\"https://github.com/johnSamilin/forest/blob/develop/src/utils/ForestGenerator.ts\">\r\n          репозитории\r\n        </Link>\r\n        .\r\n      </p>\r\n      <h2>Камера, мотор</h2>\r\n      <p>\r\n        Представим, что у нас есть уже настроенная сцена на{\" \"}\r\n        <em>react-three-fiber</em>: равнина, которую предстоит засеять\r\n        деревьями, камера и свет.\r\n      </p>\r\n      <p>\r\n        Как следует из статьи, работа алгоритма имитации леса зависит от\r\n        параметров:\r\n        <ul>\r\n          <li>\r\n            n<sub>f</sub> - начальное количество деревьев.\r\n          </li>\r\n          <li>\r\n            R<sub>s</sub> - радиус, внутри которого падают семена.\r\n          </li>\r\n          <li>\r\n            S<sub>s</sub> - количество семян, которые падают в каждой итерации.\r\n          </li>\r\n          <li>\r\n            d<sub>s</sub> - вероятность гибели семян.\r\n          </li>\r\n          <li>\r\n            F<sub>c</sub> - желаемый уровень покрытия поверхности лесом.\r\n          </li>\r\n        </ul>\r\n        Изначально разбрасываем по полю несколько деревьев (n<sub>f</sub>),\r\n        затем повторяем этап роста столько раз, сколько потребуется для\r\n        желаемого уровня покрытия. Каждый этап роста сопровождается:\r\n        <ol>\r\n          <li>падением семян</li>\r\n          <li>ростом деревьем</li>\r\n          <li>гибелью семян :(</li>\r\n        </ol>\r\n      </p>\r\n      <p>\r\n        Хорошо, алгоритм работает. И результатом его работы является матрица с\r\n        числами от 1 до 3 и массив координат, на которых должны располагаться\r\n        деревья. Зачем нам матрица, спросите вы. Затем, что она показывает\r\n        проходимые (пусто) и непроходимые (дерево) области, а мы хотим знать{\" \"}\r\n        <del>где сидит фазан</del> это, чтобы использовать в алгоритме <Link to=\"/pathfinding\">поиска\r\n        пути</Link>. Итак, что же получилось?\r\n      </p>\r\n      <p className=\"screen\">\r\n        <img src=\"/images/trees-close.PNG\" />\r\n      </p>\r\n      <p>\r\n        Выглядит не очень. Все потому, что трехмерные объекты обладают размерами\r\n        и нужно с этим считаться. Предположим, что каждая ячейка{\" \"}\r\n        <em>матрицы проходимости</em> представляет собой ячейку поверхности в\r\n        сцене размером <strong>NxN</strong>. Тогда для того, чтобы получить\r\n        реальные координаты дерева, нужно просто умножить их на N. Но все равно\r\n        чего-то не хватает.\r\n      </p>\r\n      <h2>Точки опоры</h2>\r\n      <p>\r\n        Когда вы хотите расположить объект в трехмерной сцене в точке [0, 0, 0],\r\n        где вы ожидаете его увидеть? Если это окно браузера, то, вероятно, в\r\n        углу плоскости. <em>Нет</em>. Центр системы координат в такой сцене\r\n        совпадает с центром плоскости, и для того, чтобы правильно разместить\r\n        лес по поверхности, нужно вычесть из координат каждого дерева &frac14;\r\n        ширины или длины плоскости.\r\n      </p>\r\n      <p>\r\n        Теперь у нас две проблемы. Во-первых, деревья расположены так, как\r\n        должны, за одним исключением. Часть из них, те, что растут густо,\r\n        выстроились в ровные ряды, как будто их сажали юннаты. Во-вторых, все\r\n        они одного возраста и роста. За возраст можно взять то количество циклов\r\n        генерации, которое \"прожило\" дерево. От него может зависеть его рост и\r\n        количество падающих семян (S<sub>s</sub>). Это не совсем то, чего\r\n        ожидаешь от дикой природы, так что давайте добавим в{\" \"}\r\n        <em>случайное распределение</em> элемент случайности.\r\n      </p>\r\n      <div className=\"compare\">\r\n        <p className=\"screen\">\r\n          <img src=\"/images/trees-translated.PNG\" />\r\n        </p>\r\n        <ReactRough\r\n          width={110}\r\n          height={160}\r\n          config={{\r\n            options: {\r\n              roughness: 2,\r\n            },\r\n          }}\r\n        >\r\n          <Curve\r\n            points={[\r\n              [50, 0],\r\n              [100, 20],\r\n              [20, 100],\r\n              [50, 150],\r\n            ]}\r\n            stroke=\"red\"\r\n          />\r\n          <Line x1={50} x2={50} y1={125} y2={150} stroke=\"red\" />\r\n          <Line x1={50} x2={30} y1={150} y2={150} stroke=\"red\" />\r\n        </ReactRough>\r\n        <p className=\"screen\">\r\n          <img src=\"/images/trees-final.PNG\" />\r\n        </p>\r\n      </div>\r\n      <p>И получим вполне реалистичный лес.</p>\r\n      <p className=\"date\">\r\n          1 июля 2020\r\n      </p>\r\n      <Footer />\r\n    </article>\r\n  </Layout>\r\n)\r\n\r\nexport default IndexPage\r\n"],"sourceRoot":""}