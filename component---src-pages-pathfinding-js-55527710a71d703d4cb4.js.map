{"version":3,"sources":["webpack:///./src/components/images/pathfinding/profile-img-pathfinding-threaded.js","webpack:///./src/components/images/pathfinding/profile-img-pathfinding-js.js","webpack:///./src/components/images/pathfinding/profile-img-pathfinding-as.js","webpack:///./src/pages/pathfinding.js","webpack:///./src/components/images/pathfinding/profile-img-pathfinding-go.js"],"names":["ProfileImgPathfindingJsThreaded","src","data","fluid","placeholderImage","childImageSharp","ProfileImgPathfindingJs","ProfileImgPathfindingAs","Page","className","path","lang","title","frameBorder","to","ProfileImgPathfindingGo"],"mappings":"0LAIaA,EAAkC,SAAC,GAAY,EAAVC,IAAW,IACrDC,EAAI,OAcV,OAAO,kBAAC,IAAD,CAAKC,MAAOD,EAAKE,iBAAiBC,gBAAgBF,U,gICf9CG,EAA0B,SAAC,GAAY,EAAVL,IAAW,IAC7CC,EAAI,OAcV,OAAO,kBAAC,IAAD,CAAKC,MAAOD,EAAKE,iBAAiBC,gBAAgBF,U,uJCf9CI,EAA0B,SAAC,GAAY,EAAVN,IAAW,IAC7CC,EAAI,OAcV,OAAO,kBAAC,IAAD,CAAKC,MAAOD,EAAKE,iBAAiBC,gBAAgBF,U,mxDCnB3D,4IA4MeK,UA/LF,kBACX,kBAAC,IAAD,CAAQC,UAAU,mBAAmBC,KAAK,eACxC,kBAAC,IAAD,CAAKC,KAAK,KAAKC,MAAM,kBACrB,4BAAQH,UAAU,QAChB,0CACA,yGAIF,4BACEA,UAAU,mBACVI,YAAY,IACZZ,IAAI,iCAEN,iCACE,uBAAGQ,UAAU,UAAb,kBACiB,kBAAC,OAAD,CAAMK,GAAG,WAAT,iBADjB,uDAEuC,IACrC,kBAAC,OAAD,CAAMA,GAAG,6BAAT,UAHF,kgBAaA,kCACA,guBAaA,sNAG2D,IACzD,kBAAC,OAAD,CAAMA,GAAG,gDAAT,kBAJF,uZAYmE,IACjE,kBAAC,OAAD,CAAMA,GAAG,sFAAT,kBAIF,2BACE,wEACA,kBAAC,IAAD,OAEF,+CACA,wdAOuB,IACrB,kBAAC,OAAD,CAAMA,GAAG,4FAAT,UAEQ,IAVV,+EAYS,yCAZT,KAaE,kBAAC,OAAD,CAAMA,GAAG,sGAAT,UAbF,MAkBA,2BACE,4EACA,kBAAC,IAAD,OAEF,6CACA,iEACsC,IACpC,kBAAC,OAAD,CAAMA,GAAG,8HAAT,qCAFF,wKAOmC,kDAPnC,0KAUgB,2CAVhB,sKAcA,qTAIkE,IAChE,kBAAC,OAAD,CAAMA,GAAG,2EAAT,gBALF,2fAgBE,4BACE,yNAKA,oKAIA,6KAMF,kBAAC,OAAD,CAAMA,GAAG,iDAAT,qBAIF,2BACE,wEACA,kBAAC,IAAD,OAEF,oCACA,oCACQ,iDADR,wMAIkB,IAChB,kBAAC,OAAD,CAAMA,GAAG,sDAAT,sCAEQ,IAPV,eAQc,0CARd,yJAUsD,IACpD,kBAAC,OAAD,CAAMA,GAAG,6DAAT,OAXF,KAgBA,2BACE,mFACA,kBAAC,IAAD,OAEF,uDACA,gfASA,sCACA,qCACU,IACR,kBAAC,OAAD,CAAMA,GAAG,oEAAT,sBAEQ,IAJV,0DAOA,oCACA,2BACE,6BADF,oEAIA,uBAAGL,UAAU,QAAb,gBACA,kBAAC,IAAD,U,ivKCnMOM,EAA0B,SAAC,GAAY,EAAVd,IAAW,IAC7CC,EAAI,OAcV,OAAO,kBAAC,IAAD,CAAKC,MAAOD,EAAKE,iBAAiBC,gBAAgBF","file":"component---src-pages-pathfinding-js-55527710a71d703d4cb4.js","sourcesContent":["import React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport Img from \"gatsby-image\"\n\nexport const ProfileImgPathfindingJsThreaded = ({ src }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      placeholderImage: file(\n        relativePath: { eq: \"profile-pathfinding-threaded.JPG\" }\n      ) {\n        childImageSharp {\n          fluid(maxWidth: 1920) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n    }\n  `)\n\n  return <Img fluid={data.placeholderImage.childImageSharp.fluid} />\n}\n","import React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport Img from \"gatsby-image\"\n\nexport const ProfileImgPathfindingJs = ({ src }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      placeholderImage: file(\n        relativePath: { eq: \"profile-pathfinding-js.JPG\" }\n      ) {\n        childImageSharp {\n          fluid(maxWidth: 1920) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n    }\n  `)\n\n  return <Img fluid={data.placeholderImage.childImageSharp.fluid} />\n}\n","import React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport Img from \"gatsby-image\"\n\nexport const ProfileImgPathfindingAs = ({ src }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      placeholderImage: file(\n        relativePath: { eq: \"profile-pathfinding-as.JPG\" }\n      ) {\n        childImageSharp {\n          fluid(maxWidth: 1920) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n    }\n  `)\n\n  return <Img fluid={data.placeholderImage.childImageSharp.fluid} />\n}\n","import React from \"react\"\nimport { Link } from \"gatsby\"\n\nimport Layout from \"../components/layout\"\nimport SEO from \"../components/seo\"\n\nimport \"./pathfinding.css\"\nimport { ProfileImgPathfindingJs } from \"../components/images/pathfinding/profile-img-pathfinding-js\"\nimport { ProfileImgPathfindingJsThreaded } from \"../components/images/pathfinding/profile-img-pathfinding-threaded\"\nimport { ProfileImgPathfindingGo } from \"../components/images/pathfinding/profile-img-pathfinding-go\"\nimport { ProfileImgPathfindingAs } from \"../components/images/pathfinding/profile-img-pathfinding-as\"\nimport { Footer } from \"../components/footer\"\n\nconst Page = () => (\n  <Layout className=\"pathfinding-page\" path=\"pathfinding\">\n    <SEO lang=\"ru\" title=\"О поиске пути\" />\n    <header className=\"lead\">\n      <h1>Поиск пути</h1>\n      <summary>\n        Это история о том, что свой путь можно найти несколькими способами.\n      </summary>\n    </header>\n    <iframe\n      className=\"pathfinding-demo\"\n      frameBorder=\"0\"\n      src=\"/pathfinding-demo/index.html\"\n    />\n    <article>\n      <p className=\"letter\">\n        Когда я создал <Link to=\"/forest\">сцену с лесом</Link> и добавил туда\n        персонажа (которого, кстати, взял на{\" \"}\n        <Link to=\"https://www.mixamo.com/#/\">Mixamo</Link>), я подумал, что этот\n        персонаж не может просто стоять на карте, как истукан, а должен уметь по\n        ней передвигаться. Но не просто из точки А в точку Б, а с учетом\n        препятствий. Раз уж наш пока что лирический герой находится в лесу, то\n        должен уметь обходить деревья. Для меня это совершенно новый опыт и,\n        возможно, люди, которые больше меня подкованы в теме разработки игр и\n        алгоритмах, найдут этот текст дилетантским, но мне было интересно\n        разбираться в том, как работает один из молотов, кующих разработчика,\n        А*.\n      </p>\n      <h2>A*</h2>\n      <p>\n        Если представить поверхность, по которой нужно перемещаться персонажу,\n        сеткой, то поиск пути от одной клетки до другой - это задача поиска в\n        графе. Один из самых оптимальных способов это сделать - применить\n        алгоритм, которому уже 62 года. Представим, что у каждой клетки есть\n        некоторая проходимость - чем сложнее по ней передвигаться, тем выше\n        стоимость передвижения. Некоторые клетки (те, на которых есть деревья),\n        вообще непроходмы. Задача А* - найти такой путь, который будет иметь\n        минимальную стоимость, то есть будет самым быстрым. Для этого для каждой\n        клетки дополнительно еще используется эвристическая оценка, которая\n        показывает, насколько перспективным решением будет пойти в ту или иную\n        сторону.\n      </p>\n      <p>\n        Раз уж так получилось, что я занимаюсь фронтендом и мне интересны\n        возможности веб-платформы, самым логичным шагом было начать с\n        javascript-имплементации. Существует отличная библиотека{\" \"}\n        <Link to=\"http://qiao.github.io/PathFinding.js/visual/\">\n          PathFinding.js\n        </Link>\n        , в которой собран десяток различных вариантов этого алгоритма и\n        несколько видов эвристик. По ссылке можно посмотреть на статистику:\n        сколько проходит итераций поиска, сколько он занимает времени. Самым\n        оптимальным, на мой взгляд, был двунаправленный Best First Search с\n        эвристикой Octile. Дополнительно он может свернуть путь до небольшого\n        количества ключевых точек, определяющих, где находятся повороты.{\" \"}\n        <Link to=\"https://github.com/johnSamilin/forest/blob/pathfinding/src/utils/pathfinding/js.ts\">\n          Ссылка на код\n        </Link>\n      </p>\n      <p>\n        <strong>Профиль производительности js-версии</strong>\n        <ProfileImgPathfindingJs />\n      </p>\n      <h2>А можно мощнее?</h2>\n      <p>\n        Javascript - штука однопоточная, и если иметь дело с большой или\n        запутанной картой, вычисления могут повлиять на отзывчивость интерфейса.\n        Браузер и без того занят тем, что выполняет кучу работы по визуализации\n        сцены каждые 16 миллисекунд, и правильным решением было бы ему помочь.\n        Например, вынеся задачу поиска пути в отдельный поток, в воркер. По\n        идее, это должно освободить основной поток для выполнения и планирования\n        более важной работы.{\" \"}\n        <Link to=\"https://github.com/johnSamilin/forest/blob/pathfinding/src/utils/pathfinding/threaded.ts\">\n          Ссылка\n        </Link>{\" \"}\n        на тот же самый код, что и в предыдущем примере, но уже перенесенный\n        внурть <em>работника</em> (\n        <Link to=\"https://github.com/johnSamilin/forest/blob/pathfinding/src/utils/pathfinding/pathfinding.worker.ts\">\n          Github\n        </Link>\n        ).\n      </p>\n      <p>\n        <strong>Профиль производительности worker-версии</strong>\n        <ProfileImgPathfindingJsThreaded />\n      </p>\n      <h2>А еще мощнее?</h2>\n      <p>\n        JS-версия, я уверен, использует все{\" \"}\n        <Link to=\"https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e\">\n          возможности движка по оптимизации\n        </Link>\n        , как например, hidden classes и кеширование, и при использовании\n        TypeScript можно быть в той или иной степени уверенным в том, что\n        параметры, передающиеся в методы <strong>PathFinding.js</strong>, будут\n        всегда одного и того же типа. Это, в свою очередь, не будет приводить к\n        их деоптимизации. Но еще интересней попробовать запустить этот процесс в\n        WebAssembly с <em>near-native</em> скоростью. С точки зрения\n        веб-технологий это еще более любопытно, потому что, несмотря на 10 лет\n        своего существования, WebAssembly не используется так уж широко.\n      </p>\n      <p>\n        WebAssembly можно скомпилировать из десятка языков, включая C++, Go и\n        Rust. Так как я не умею писать ни на одном из них, то можно просто найти\n        готовое решение и скомпилировать его под свои нужды. Я выбрал Go, потому\n        что... не знаю, просто попробовать. Благодаря отличному разбору{\" \"}\n        <Link to=\"https://www.aaron-powell.com/posts/2019-02-05-golang-wasm-2-writing-go/\">\n          Aaron Powell\n        </Link>\n        , все оказалось не так уж и сложно и заняло буквально один день. Штука в\n        том (и об этом есть упоминание в статье), что Wasm, скомпилированный из\n        Go, ведет себя как отдельная подпрограмма. В ней можно использовать\n        состояние и не инициализировать граф с препятствиями при каждом вызове.\n        Учитывая, что в конкретно этой моей WebGL-сцене поиск пути выполняется\n        при движении мыши над плоскостью, это может сэкономить некоторое\n        количество ресурсов. Хотя этот же факт может привести к нежелательным\n        последствиям:\n        <ul>\n          <li>\n            исключение, выброшенное внутри Wasm-модуля, означает, что поток,\n            который не дает Go-скрипту завершиться, закрывается и повторная\n            попытка вызвать какие-то из его функций будет неудачной;\n          </li>\n          <li>\n            Go не экспортирует никаких функций, он регистрирует обработчики в\n            глобальной области видимости. Это может привести к конфликту имен;\n          </li>\n          <li>\n            то, что через все ту же глобальную область видимости он может\n            манипулировать DOM, на мой взгляд, делает Go потенциально\n            небезопасной штукой.\n          </li>\n        </ul>\n        <Link to=\"https://github.com/johnSamilin/go-pathfinding\">\n          Go-имплементация\n        </Link>\n      </p>\n      <p>\n        <strong>Профиль производительности go-версии</strong>\n        <ProfileImgPathfindingGo />\n      </p>\n      <h2>Еще!</h2>\n      <p>\n        Чтобы <del>совсем упороться</del> не пренебрегать возможностями Wasm по\n        управлению памятью, я решил пойти на эксперимент и написать рализацию А*\n        самому на AssmeblyScript. Это версия TypeScript с чуть более строгими\n        ограничениями и{\" \"}\n        <Link to=\"https://www.assemblyscript.org/stdlib/map.html#map\">\n          разницей в поведении базовых типов\n        </Link>{\" \"}\n        (к примеру, <em>Map.keys()</em> возвращает не итератор, а массив\n        ключей). В случае чего, AssmeblyScript-код можно довольно быстро\n        преобразовать в TypeScript. Увидеть результат можно{\" \"}\n        <Link to=\"https://github.com/johnSamilin/assemblyscript-pathfinding\">\n          тут\n        </Link>\n        .\n      </p>\n      <p>\n        <strong>Профиль производительности AssembyScript-версии</strong>\n        <ProfileImgPathfindingAs />\n      </p>\n      <h2>Как теперь с этим жить?</h2>\n      <p>\n        Я надеялся, что простая миграция миграция кода с уровня браузера на\n        уровен WebAssembly даст прирость производительности и избавит от\n        головной боли по оптимизации. Но, как видно из скриншотов\n        профилировщика, большой разницы нет. Wasm-версии работают даже немного\n        хуже в периоды интенсивной деятельности. FPS снижается иногда до 1-2\n        кадров в секунду, и в это время сильно нагружен GPU. Эксперимент\n        завершился, самый правильный выбор - полагаться на браузерный движок.\n      </p>\n      <h3>Update</h3>\n      <p>\n        Простые{\" \"}\n        <Link to=\"https://github.com/johnSamilin/assemblyscript-pathfinding/pull/1\">\n          оптимизации сборки\n        </Link>{\" \"}\n        могут ускорить WebAssembly-версию в 4 раза. ¯\\_(ツ)_/¯\n      </p>\n      <h3>P.S.</h3>\n      <p>\n        <br />\n        Да, я знаю, он никуда не идет. Но ведь они никуда и не спешит :)\n      </p>\n      <p className=\"date\">13 июля 2020</p>\n      <Footer />\n    </article>\n  </Layout>\n)\n\nexport default Page\n","import React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport Img from \"gatsby-image\"\n\nexport const ProfileImgPathfindingGo = ({ src }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      placeholderImage: file(\n        relativePath: { eq: \"profile-pathfinding-go.JPG\" }\n      ) {\n        childImageSharp {\n          fluid(maxWidth: 1920) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n    }\n  `)\n\n  return <Img fluid={data.placeholderImage.childImageSharp.fluid} />\n}\n"],"sourceRoot":""}