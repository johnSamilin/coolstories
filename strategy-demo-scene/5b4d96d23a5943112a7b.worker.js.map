{"version":3,"sources":["../webpack/bootstrap","../node_modules/pathfinding/src/core/DiagonalMovement.js","../node_modules/pathfinding/src/core/Util.js","../node_modules/pathfinding/src/core/Heuristic.js","../node_modules/heap/index.js","../node_modules/pathfinding/src/finders/JumpPointFinderBase.js","../node_modules/pathfinding/index.js","../node_modules/pathfinding/src/core/Node.js","../node_modules/pathfinding/src/finders/AStarFinder.js","../node_modules/pathfinding/src/finders/BiAStarFinder.js","../node_modules/@babel/runtime/regenerator/index.js","../node_modules/regenerator-runtime/runtime.js","../node_modules/pathfinding/src/PathFinding.js","../node_modules/heap/lib/heap.js","../node_modules/webpack/buildin/module.js","../node_modules/pathfinding/src/core/Grid.js","../node_modules/pathfinding/src/finders/BestFirstFinder.js","../node_modules/pathfinding/src/finders/BreadthFirstFinder.js","../node_modules/pathfinding/src/finders/DijkstraFinder.js","../node_modules/pathfinding/src/finders/BiBestFirstFinder.js","../node_modules/pathfinding/src/finders/BiBreadthFirstFinder.js","../node_modules/pathfinding/src/finders/BiDijkstraFinder.js","../node_modules/pathfinding/src/finders/IDAStarFinder.js","../node_modules/pathfinding/src/finders/JumpPointFinder.js","../node_modules/pathfinding/src/finders/JPFNeverMoveDiagonally.js","../node_modules/pathfinding/src/finders/JPFAlwaysMoveDiagonally.js","../node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfNoObstacles.js","../node_modules/pathfinding/src/finders/JPFMoveDiagonallyIfAtMostOneObstacle.js","../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","utils/pathfinding/js.ts","utils/pathfinding/pathfinding.worker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Always","Never","IfAtMostOneObstacle","OnlyWhenNoObstacles","backtrace","node","path","x","y","parent","push","reverse","interpolate","x0","y0","x1","y1","sx","sy","dx","dy","err","e2","abs","Math","line","biBacktrace","nodeA","nodeB","pathA","pathB","concat","pathLength","a","b","sum","length","sqrt","expandPath","coord0","coord1","interpolated","interpolatedLen","j","expanded","len","smoothenPath","grid","newPath","coord","testCoord","blocked","isWalkableAt","lastValidCoord","compressPath","lx","ly","ldx","ldy","sq","compressed","px","py","manhattan","euclidean","octile","F","SQRT2","chebyshev","max","require","Heap","Util","Heuristic","JumpPointFinderBase","opt","this","heuristic","trackJumpRecursion","findPath","startX","startY","endX","endY","openList","f","startNode","getNodeAt","endNode","g","opened","empty","pop","closed","_identifySuccessors","neighbors","neighbor","jumpPoint","jx","jy","ng","jumpNode","_findNeighbors","_jump","h","updateItem","walkable","undefined","DiagonalMovement","AStarFinder","allowDiagonal","dontCrossCorners","weight","diagonalMovement","getNeighbors","BiAStarFinder","cmp","startOpenList","endOpenList","runtime","Op","hasOwn","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","method","arg","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","makeInvokeMethod","fn","obj","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","constructor","displayName","isGeneratorFunction","genFun","ctor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","toString","keys","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","defaultCmp","floor","heapify","heappop","heappush","heappushpop","heapreplace","insort","min","nlargest","nsmallest","_siftdown","_siftup","lo","hi","mid","splice","apply","array","item","lastelt","returnitem","_ref","_i","_len","_ref1","_results","_results1","_j","pos","indexOf","elem","sort","los","startpos","newitem","parentpos","childpos","endpos","rightpos","nodes","replace","pushpop","peek","contains","clear","size","clone","heap","toArray","insert","top","front","has","copy","window","webpackPolyfill","deprecate","paths","children","Node","Grid","width_or_matrix","height","matrix","width","_buildNodes","Array","isInside","setWalkableAt","s0","d0","s1","d1","s2","d2","s3","d3","thisNodes","newGrid","newNodes","BestFirstFinder","orig","BreadthFirstFinder","shift","DijkstraFinder","BiBestFirstFinder","BiBreadthFirstFinder","by","BiDijkstraFinder","IDAStarFinder","trackRecursion","timeLimit","Infinity","route","startTime","Date","getTime","search","cutoff","depth","k","neighbour","end","neighbours","retainCount","tested","start","cutOff","JPFNeverMoveDiagonally","JPFAlwaysMoveDiagonally","JPFMoveDiagonallyIfNoObstacles","JPFMoveDiagonallyIfAtMostOneObstacle","neighborNodes","neighborNode","isNextWalkable","isTopWalkable","isBottomWalkable","isRightWalkable","isLeftWalkable","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","arguments","finder","from","to","trunc","Module","initPathfinding","startPathFinding","setObstacles","obstacles","findPathAsync","res","ctx","addEventListener","e","data","pathfinding","operation","payload","Pathfinding","postMessage","pathfindingResult"],"mappings":"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","file":"5b4d96d23a5943112a7b.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 27);\n","var DiagonalMovement = {\r\n    Always: 1,\r\n    Never: 2,\r\n    IfAtMostOneObstacle: 3,\r\n    OnlyWhenNoObstacles: 4\r\n};\r\n\r\nmodule.exports = DiagonalMovement;","/**\r\n * Backtrace according to the parent records and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node} node End node\r\n * @return {Array<Array<number>>} the path\r\n */\r\nfunction backtrace(node) {\r\n    var path = [[node.x, node.y]];\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        path.push([node.x, node.y]);\r\n    }\r\n    return path.reverse();\r\n}\r\nexports.backtrace = backtrace;\r\n\r\n/**\r\n * Backtrace from start and end node, and return the path.\r\n * (including both start and end nodes)\r\n * @param {Node}\r\n * @param {Node}\r\n */\r\nfunction biBacktrace(nodeA, nodeB) {\r\n    var pathA = backtrace(nodeA),\r\n        pathB = backtrace(nodeB);\r\n    return pathA.concat(pathB.reverse());\r\n}\r\nexports.biBacktrace = biBacktrace;\r\n\r\n/**\r\n * Compute the length of the path.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {number} The length of the path\r\n */\r\nfunction pathLength(path) {\r\n    var i, sum = 0, a, b, dx, dy;\r\n    for (i = 1; i < path.length; ++i) {\r\n        a = path[i - 1];\r\n        b = path[i];\r\n        dx = a[0] - b[0];\r\n        dy = a[1] - b[1];\r\n        sum += Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    return sum;\r\n}\r\nexports.pathLength = pathLength;\r\n\r\n\r\n/**\r\n * Given the start and end coordinates, return all the coordinates lying\r\n * on the line formed by these coordinates, based on Bresenham's algorithm.\r\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\r\n * @param {number} x0 Start x coordinate\r\n * @param {number} y0 Start y coordinate\r\n * @param {number} x1 End x coordinate\r\n * @param {number} y1 End y coordinate\r\n * @return {Array<Array<number>>} The coordinates on the line\r\n */\r\nfunction interpolate(x0, y0, x1, y1) {\r\n    var abs = Math.abs,\r\n        line = [],\r\n        sx, sy, dx, dy, err, e2;\r\n\r\n    dx = abs(x1 - x0);\r\n    dy = abs(y1 - y0);\r\n\r\n    sx = (x0 < x1) ? 1 : -1;\r\n    sy = (y0 < y1) ? 1 : -1;\r\n\r\n    err = dx - dy;\r\n\r\n    while (true) {\r\n        line.push([x0, y0]);\r\n\r\n        if (x0 === x1 && y0 === y1) {\r\n            break;\r\n        }\r\n        \r\n        e2 = 2 * err;\r\n        if (e2 > -dy) {\r\n            err = err - dy;\r\n            x0 = x0 + sx;\r\n        }\r\n        if (e2 < dx) {\r\n            err = err + dx;\r\n            y0 = y0 + sy;\r\n        }\r\n    }\r\n\r\n    return line;\r\n}\r\nexports.interpolate = interpolate;\r\n\r\n\r\n/**\r\n * Given a compressed path, return a new path that has all the segments\r\n * in it interpolated.\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} expanded path\r\n */\r\nfunction expandPath(path) {\r\n    var expanded = [],\r\n        len = path.length,\r\n        coord0, coord1,\r\n        interpolated,\r\n        interpolatedLen,\r\n        i, j;\r\n\r\n    if (len < 2) {\r\n        return expanded;\r\n    }\r\n\r\n    for (i = 0; i < len - 1; ++i) {\r\n        coord0 = path[i];\r\n        coord1 = path[i + 1];\r\n\r\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\r\n        interpolatedLen = interpolated.length;\r\n        for (j = 0; j < interpolatedLen - 1; ++j) {\r\n            expanded.push(interpolated[j]);\r\n        }\r\n    }\r\n    expanded.push(path[len - 1]);\r\n\r\n    return expanded;\r\n}\r\nexports.expandPath = expandPath;\r\n\r\n\r\n/**\r\n * Smoothen the give path.\r\n * The original path will not be modified; a new path will be returned.\r\n * @param {PF.Grid} grid\r\n * @param {Array<Array<number>>} path The path\r\n */\r\nfunction smoothenPath(grid, path) {\r\n    var len = path.length,\r\n        x0 = path[0][0],        // path start x\r\n        y0 = path[0][1],        // path start y\r\n        x1 = path[len - 1][0],  // path end x\r\n        y1 = path[len - 1][1],  // path end y\r\n        sx, sy,                 // current start coordinate\r\n        ex, ey,                 // current end coordinate\r\n        newPath,\r\n        i, j, coord, line, testCoord, blocked;\r\n\r\n    sx = x0;\r\n    sy = y0;\r\n    newPath = [[sx, sy]];\r\n\r\n    for (i = 2; i < len; ++i) {\r\n        coord = path[i];\r\n        ex = coord[0];\r\n        ey = coord[1];\r\n        line = interpolate(sx, sy, ex, ey);\r\n\r\n        blocked = false;\r\n        for (j = 1; j < line.length; ++j) {\r\n            testCoord = line[j];\r\n\r\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\r\n                blocked = true;\r\n                break;\r\n            }\r\n        }\r\n        if (blocked) {\r\n            lastValidCoord = path[i - 1];\r\n            newPath.push(lastValidCoord);\r\n            sx = lastValidCoord[0];\r\n            sy = lastValidCoord[1];\r\n        }\r\n    }\r\n    newPath.push([x1, y1]);\r\n\r\n    return newPath;\r\n}\r\nexports.smoothenPath = smoothenPath;\r\n\r\n\r\n/**\r\n * Compress a path, remove redundant nodes without altering the shape\r\n * The original path is not modified\r\n * @param {Array<Array<number>>} path The path\r\n * @return {Array<Array<number>>} The compressed path\r\n */\r\nfunction compressPath(path) {\r\n\r\n    // nothing to compress\r\n    if(path.length < 3) {\r\n        return path;\r\n    }\r\n\r\n    var compressed = [],\r\n        sx = path[0][0], // start x\r\n        sy = path[0][1], // start y\r\n        px = path[1][0], // second point x\r\n        py = path[1][1], // second point y\r\n        dx = px - sx, // direction between the two points\r\n        dy = py - sy, // direction between the two points\r\n        lx, ly,\r\n        ldx, ldy,\r\n        sq, i;\r\n\r\n    // normalize the direction\r\n    sq = Math.sqrt(dx*dx + dy*dy);\r\n    dx /= sq;\r\n    dy /= sq;\r\n\r\n    // start the new path\r\n    compressed.push([sx,sy]);\r\n\r\n    for(i = 2; i < path.length; i++) {\r\n\r\n        // store the last point\r\n        lx = px;\r\n        ly = py;\r\n\r\n        // store the last direction\r\n        ldx = dx;\r\n        ldy = dy;\r\n\r\n        // next point\r\n        px = path[i][0];\r\n        py = path[i][1];\r\n\r\n        // next direction\r\n        dx = px - lx;\r\n        dy = py - ly;\r\n\r\n        // normalize\r\n        sq = Math.sqrt(dx*dx + dy*dy);\r\n        dx /= sq;\r\n        dy /= sq;\r\n\r\n        // if the direction has changed, store the point\r\n        if ( dx !== ldx || dy !== ldy ) {\r\n            compressed.push([lx,ly]);\r\n        }\r\n    }\r\n\r\n    // store the last point\r\n    compressed.push([px,py]);\r\n\r\n    return compressed;\r\n}\r\nexports.compressPath = compressPath;\r\n","/**\r\n * @namespace PF.Heuristic\r\n * @description A collection of heuristic functions.\r\n */\r\nmodule.exports = {\r\n\r\n  /**\r\n   * Manhattan distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} dx + dy\r\n   */\r\n  manhattan: function(dx, dy) {\r\n      return dx + dy;\r\n  },\r\n\r\n  /**\r\n   * Euclidean distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy)\r\n   */\r\n  euclidean: function(dx, dy) {\r\n      return Math.sqrt(dx * dx + dy * dy);\r\n  },\r\n\r\n  /**\r\n   * Octile distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\r\n   */\r\n  octile: function(dx, dy) {\r\n      var F = Math.SQRT2 - 1;\r\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\r\n  },\r\n\r\n  /**\r\n   * Chebyshev distance.\r\n   * @param {number} dx - Difference in x.\r\n   * @param {number} dy - Difference in y.\r\n   * @return {number} max(dx, dy)\r\n   */\r\n  chebyshev: function(dx, dy) {\r\n      return Math.max(dx, dy);\r\n  }\r\n\r\n};\r\n","module.exports = require('./lib/heap');\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Base class for the Jump Point Search algorithm\r\n * @param {object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction JumpPointFinderBase(opt) {\r\n    opt = opt || {};\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\r\n}\r\n\r\n/**\r\n * Find and return the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\r\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\r\n\r\n    this.grid = grid;\r\n\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        if (node === endNode) {\r\n            return Util.expandPath(Util.backtrace(endNode));\r\n        }\r\n\r\n        this._identifySuccessors(node);\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\n/**\r\n * Identify successors for the given node. Runs a jump point search in the\r\n * direction of each available neighbor, adding any points found to the open\r\n * list.\r\n * @protected\r\n */\r\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\r\n    var grid = this.grid,\r\n        heuristic = this.heuristic,\r\n        openList = this.openList,\r\n        endX = this.endNode.x,\r\n        endY = this.endNode.y,\r\n        neighbors, neighbor,\r\n        jumpPoint, i, l,\r\n        x = node.x, y = node.y,\r\n        jx, jy, dx, dy, d, ng, jumpNode,\r\n        abs = Math.abs, max = Math.max;\r\n\r\n    neighbors = this._findNeighbors(node);\r\n    for(i = 0, l = neighbors.length; i < l; ++i) {\r\n        neighbor = neighbors[i];\r\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\r\n        if (jumpPoint) {\r\n\r\n            jx = jumpPoint[0];\r\n            jy = jumpPoint[1];\r\n            jumpNode = grid.getNodeAt(jx, jy);\r\n\r\n            if (jumpNode.closed) {\r\n                continue;\r\n            }\r\n\r\n            // include distance, as parent may not be immediately adjacent:\r\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\r\n            ng = node.g + d; // next `g` value\r\n\r\n            if (!jumpNode.opened || ng < jumpNode.g) {\r\n                jumpNode.g = ng;\r\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\r\n                jumpNode.f = jumpNode.g + jumpNode.h;\r\n                jumpNode.parent = node;\r\n\r\n                if (!jumpNode.opened) {\r\n                    openList.push(jumpNode);\r\n                    jumpNode.opened = true;\r\n                } else {\r\n                    openList.updateItem(jumpNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = JumpPointFinderBase;\r\n","module.exports = require('./src/PathFinding');\r\n","/**\r\n * A node in grid. \r\n * This class holds some basic information about a node and custom \r\n * attributes may be added, depending on the algorithms' needs.\r\n * @constructor\r\n * @param {number} x - The x coordinate of the node on the grid.\r\n * @param {number} y - The y coordinate of the node on the grid.\r\n * @param {boolean} [walkable] - Whether this node is walkable.\r\n */\r\nfunction Node(x, y, walkable) {\r\n    /**\r\n     * The x coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.x = x;\r\n    /**\r\n     * The y coordinate of the node on the grid.\r\n     * @type number\r\n     */\r\n    this.y = y;\r\n    /**\r\n     * Whether this node can be walked through.\r\n     * @type boolean\r\n     */\r\n    this.walkable = (walkable === undefined ? true : walkable);\r\n}\r\n\r\nmodule.exports = Node;\r\n","var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction AStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    //admissible. It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = new Heap(function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        }),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n\r\n    // push the start node into the open list\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the open list is not empty\r\n    while (!openList.empty()) {\r\n        // pop the position of node which has the minimum `f` value.\r\n        node = openList.pop();\r\n        node.closed = true;\r\n\r\n        // if reached the end position, construct the path and return it\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    openList.push(neighbor);\r\n                    neighbor.opened = true;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    openList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = AStarFinder;\r\n","var Heap       = require('heap');\r\nvar Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * A* path-finder.\r\n * based upon https://github.com/bgrins/javascript-astar\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n */\r\nfunction BiAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\r\n    //It should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var cmp = function(nodeA, nodeB) {\r\n            return nodeA.f - nodeB.f;\r\n        },\r\n        startOpenList = new Heap(cmp),\r\n        endOpenList = new Heap(cmp),\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        heuristic = this.heuristic,\r\n        diagonalMovement = this.diagonalMovement,\r\n        weight = this.weight,\r\n        abs = Math.abs, SQRT2 = Math.SQRT2,\r\n        node, neighbors, neighbor, i, l, x, y, ng,\r\n        BY_START = 1, BY_END = 2;\r\n\r\n    // set the `g` and `f` value of the start node to be 0\r\n    // and push it into the start open list\r\n    startNode.g = 0;\r\n    startNode.f = 0;\r\n    startOpenList.push(startNode);\r\n    startNode.opened = BY_START;\r\n\r\n    // set the `g` and `f` value of the end node to be 0\r\n    // and push it into the open open list\r\n    endNode.g = 0;\r\n    endNode.f = 0;\r\n    endOpenList.push(endNode);\r\n    endNode.opened = BY_END;\r\n\r\n    // while both the open lists are not empty\r\n    while (!startOpenList.empty() && !endOpenList.empty()) {\r\n\r\n        // pop the position of start node which has the minimum `f` value.\r\n        node = startOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_END) {\r\n                return Util.biBacktrace(node, neighbor);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - endX), abs(y - endY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    startOpenList.push(neighbor);\r\n                    neighbor.opened = BY_START;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    startOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n\r\n\r\n        // pop the position of end node which has the minimum `f` value.\r\n        node = endOpenList.pop();\r\n        node.closed = true;\r\n\r\n        // get neigbours of the current node\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened === BY_START) {\r\n                return Util.biBacktrace(neighbor, node);\r\n            }\r\n\r\n            x = neighbor.x;\r\n            y = neighbor.y;\r\n\r\n            // get the distance between current node and the neighbor\r\n            // and calculate the next g score\r\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\r\n\r\n            // check if the neighbor has not been inspected yet, or\r\n            // can be reached with smaller cost from the current node\r\n            if (!neighbor.opened || ng < neighbor.g) {\r\n                neighbor.g = ng;\r\n                neighbor.h = neighbor.h ||\r\n                    weight * heuristic(abs(x - startX), abs(y - startY));\r\n                neighbor.f = neighbor.g + neighbor.h;\r\n                neighbor.parent = node;\r\n\r\n                if (!neighbor.opened) {\r\n                    endOpenList.push(neighbor);\r\n                    neighbor.opened = BY_END;\r\n                } else {\r\n                    // the neighbor can be reached with smaller cost.\r\n                    // Since its f value has been updated, we have to\r\n                    // update its position in the open list\r\n                    endOpenList.updateItem(neighbor);\r\n                }\r\n            }\r\n        } // end for each neighbor\r\n    } // end while not open list empty\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiAStarFinder;\r\n","module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","module.exports = {\r\n    'Heap'                      : require('heap'),\r\n    'Node'                      : require('./core/Node'),\r\n    'Grid'                      : require('./core/Grid'),\r\n    'Util'                      : require('./core/Util'),\r\n    'DiagonalMovement'          : require('./core/DiagonalMovement'),\r\n    'Heuristic'                 : require('./core/Heuristic'),\r\n    'AStarFinder'               : require('./finders/AStarFinder'),\r\n    'BestFirstFinder'           : require('./finders/BestFirstFinder'),\r\n    'BreadthFirstFinder'        : require('./finders/BreadthFirstFinder'),\r\n    'DijkstraFinder'            : require('./finders/DijkstraFinder'),\r\n    'BiAStarFinder'             : require('./finders/BiAStarFinder'),\r\n    'BiBestFirstFinder'         : require('./finders/BiBestFirstFinder'),\r\n    'BiBreadthFirstFinder'      : require('./finders/BiBreadthFirstFinder'),\r\n    'BiDijkstraFinder'          : require('./finders/BiDijkstraFinder'),\r\n    'IDAStarFinder'             : require('./finders/IDAStarFinder'),\r\n    'JumpPointFinder'           : require('./finders/JumpPointFinder'),\r\n};\r\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","var Node = require('./Node');\r\nvar DiagonalMovement = require('./DiagonalMovement');\r\n\r\n/**\r\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\r\n * @constructor\r\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\r\n * @param {number} height Number of rows of the grid.\r\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\r\n *     representing the walkable status of the nodes(0 or false for walkable).\r\n *     If the matrix is not supplied, all the nodes will be walkable.  */\r\nfunction Grid(width_or_matrix, height, matrix) {\r\n    var width;\r\n\r\n    if (typeof width_or_matrix !== 'object') {\r\n        width = width_or_matrix;\r\n    } else {\r\n        height = width_or_matrix.length;\r\n        width = width_or_matrix[0].length;\r\n        matrix = width_or_matrix;\r\n    }\r\n\r\n    /**\r\n     * The number of columns of the grid.\r\n     * @type number\r\n     */\r\n    this.width = width;\r\n    /**\r\n     * The number of rows of the grid.\r\n     * @type number\r\n     */\r\n    this.height = height;\r\n\r\n    /**\r\n     * A 2D array of nodes.\r\n     */\r\n    this.nodes = this._buildNodes(width, height, matrix);\r\n}\r\n\r\n/**\r\n * Build and return the nodes.\r\n * @private\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\r\n *     the walkable status of the nodes.\r\n * @see Grid\r\n */\r\nGrid.prototype._buildNodes = function(width, height, matrix) {\r\n    var i, j,\r\n        nodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        nodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            nodes[i][j] = new Node(j, i);\r\n        }\r\n    }\r\n\r\n\r\n    if (matrix === undefined) {\r\n        return nodes;\r\n    }\r\n\r\n    if (matrix.length !== height || matrix[0].length !== width) {\r\n        throw new Error('Matrix size does not fit');\r\n    }\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        for (j = 0; j < width; ++j) {\r\n            if (matrix[i][j]) {\r\n                // 0, false, null will be walkable\r\n                // while others will be un-walkable\r\n                nodes[i][j].walkable = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n};\r\n\r\n\r\nGrid.prototype.getNodeAt = function(x, y) {\r\n    return this.nodes[y][x];\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the node at the given position is walkable.\r\n * (Also returns false if the position is outside the grid.)\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @return {boolean} - The walkability of the node.\r\n */\r\nGrid.prototype.isWalkableAt = function(x, y) {\r\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\r\n};\r\n\r\n\r\n/**\r\n * Determine whether the position is inside the grid.\r\n * XXX: `grid.isInside(x, y)` is wierd to read.\r\n * It should be `(x, y) is inside grid`, but I failed to find a better\r\n * name for this method.\r\n * @param {number} x\r\n * @param {number} y\r\n * @return {boolean}\r\n */\r\nGrid.prototype.isInside = function(x, y) {\r\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\r\n};\r\n\r\n\r\n/**\r\n * Set whether the node on the given position is walkable.\r\n * NOTE: throws exception if the coordinate is not inside the grid.\r\n * @param {number} x - The x coordinate of the node.\r\n * @param {number} y - The y coordinate of the node.\r\n * @param {boolean} walkable - Whether the position is walkable.\r\n */\r\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\r\n    this.nodes[y][x].walkable = walkable;\r\n};\r\n\r\n\r\n/**\r\n * Get the neighbors of the given node.\r\n *\r\n *     offsets      diagonalOffsets:\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 0 |   |    | 0 |   | 1 |\r\n *  +---+---+---+    +---+---+---+\r\n *  | 3 |   | 1 |    |   |   |   |\r\n *  +---+---+---+    +---+---+---+\r\n *  |   | 2 |   |    | 3 |   | 2 |\r\n *  +---+---+---+    +---+---+---+\r\n *\r\n *  When allowDiagonal is true, if offsets[i] is valid, then\r\n *  diagonalOffsets[i] and\r\n *  diagonalOffsets[(i + 1) % 4] is valid.\r\n * @param {Node} node\r\n * @param {DiagonalMovement} diagonalMovement\r\n */\r\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\r\n    var x = node.x,\r\n        y = node.y,\r\n        neighbors = [],\r\n        s0 = false, d0 = false,\r\n        s1 = false, d1 = false,\r\n        s2 = false, d2 = false,\r\n        s3 = false, d3 = false,\r\n        nodes = this.nodes;\r\n\r\n    // ↑\r\n    if (this.isWalkableAt(x, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x]);\r\n        s0 = true;\r\n    }\r\n    // →\r\n    if (this.isWalkableAt(x + 1, y)) {\r\n        neighbors.push(nodes[y][x + 1]);\r\n        s1 = true;\r\n    }\r\n    // ↓\r\n    if (this.isWalkableAt(x, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x]);\r\n        s2 = true;\r\n    }\r\n    // ←\r\n    if (this.isWalkableAt(x - 1, y)) {\r\n        neighbors.push(nodes[y][x - 1]);\r\n        s3 = true;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.Never) {\r\n        return neighbors;\r\n    }\r\n\r\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        d0 = s3 && s0;\r\n        d1 = s0 && s1;\r\n        d2 = s1 && s2;\r\n        d3 = s2 && s3;\r\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\r\n        d0 = s3 || s0;\r\n        d1 = s0 || s1;\r\n        d2 = s1 || s2;\r\n        d3 = s2 || s3;\r\n    } else if (diagonalMovement === DiagonalMovement.Always) {\r\n        d0 = true;\r\n        d1 = true;\r\n        d2 = true;\r\n        d3 = true;\r\n    } else {\r\n        throw new Error('Incorrect value of diagonalMovement');\r\n    }\r\n\r\n    // ↖\r\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x - 1]);\r\n    }\r\n    // ↗\r\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\r\n        neighbors.push(nodes[y - 1][x + 1]);\r\n    }\r\n    // ↘\r\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x + 1]);\r\n    }\r\n    // ↙\r\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\r\n        neighbors.push(nodes[y + 1][x - 1]);\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\n\r\n/**\r\n * Get a clone of this grid.\r\n * @return {Grid} Cloned grid.\r\n */\r\nGrid.prototype.clone = function() {\r\n    var i, j,\r\n\r\n        width = this.width,\r\n        height = this.height,\r\n        thisNodes = this.nodes,\r\n\r\n        newGrid = new Grid(width, height),\r\n        newNodes = new Array(height);\r\n\r\n    for (i = 0; i < height; ++i) {\r\n        newNodes[i] = new Array(width);\r\n        for (j = 0; j < width; ++j) {\r\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\r\n        }\r\n    }\r\n\r\n    newGrid.nodes = newNodes;\r\n\r\n    return newGrid;\r\n};\r\n\r\nmodule.exports = Grid;\r\n","var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Best-First-Search path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BestFirstFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBestFirstFinder.prototype = new AStarFinder();\r\nBestFirstFinder.prototype.constructor = BestFirstFinder;\r\n\r\nmodule.exports = BestFirstFinder;\r\n","var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var openList = [],\r\n        diagonalMovement = this.diagonalMovement,\r\n        startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        neighbors, neighbor, node, i, l;\r\n\r\n    // push the start pos into the queue\r\n    openList.push(startNode);\r\n    startNode.opened = true;\r\n\r\n    // while the queue is not empty\r\n    while (openList.length) {\r\n        // take the front node from the queue\r\n        node = openList.shift();\r\n        node.closed = true;\r\n\r\n        // reached the end position\r\n        if (node === endNode) {\r\n            return Util.backtrace(endNode);\r\n        }\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            // skip this neighbor if it has been inspected before\r\n            if (neighbor.closed || neighbor.opened) {\r\n                continue;\r\n            }\r\n\r\n            openList.push(neighbor);\r\n            neighbor.opened = true;\r\n            neighbor.parent = node;\r\n        }\r\n    }\r\n    \r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BreadthFirstFinder;\r\n","var AStarFinder = require('./AStarFinder');\r\n\r\n/**\r\n * Dijkstra path-finder.\r\n * @constructor\r\n * @extends AStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction DijkstraFinder(opt) {\r\n    AStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nDijkstraFinder.prototype = new AStarFinder();\r\nDijkstraFinder.prototype.constructor = DijkstraFinder;\r\n\r\nmodule.exports = DijkstraFinder;\r\n","var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-direcitional Best-First-Search path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n */\r\nfunction BiBestFirstFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n\r\n    var orig = this.heuristic;\r\n    this.heuristic = function(dx, dy) {\r\n        return orig(dx, dy) * 1000000;\r\n    };\r\n}\r\n\r\nBiBestFirstFinder.prototype = new BiAStarFinder();\r\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\r\n\r\nmodule.exports = BiBestFirstFinder;\r\n","var Util = require('../core/Util');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Bi-directional Breadth-First-Search path finder.\r\n * @constructor\r\n * @param {object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiBreadthFirstFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Find and return the the path.\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    var startNode = grid.getNodeAt(startX, startY),\r\n        endNode = grid.getNodeAt(endX, endY),\r\n        startOpenList = [], endOpenList = [],\r\n        neighbors, neighbor, node,\r\n        diagonalMovement = this.diagonalMovement,\r\n        BY_START = 0, BY_END = 1,\r\n        i, l;\r\n\r\n    // push the start and end nodes into the queues\r\n    startOpenList.push(startNode);\r\n    startNode.opened = true;\r\n    startNode.by = BY_START;\r\n\r\n    endOpenList.push(endNode);\r\n    endNode.opened = true;\r\n    endNode.by = BY_END;\r\n\r\n    // while both the queues are not empty\r\n    while (startOpenList.length && endOpenList.length) {\r\n\r\n        // expand start open list\r\n\r\n        node = startOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                // if this node has been inspected by the reversed search,\r\n                // then a path is found.\r\n                if (neighbor.by === BY_END) {\r\n                    return Util.biBacktrace(node, neighbor);\r\n                }\r\n                continue;\r\n            }\r\n            startOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_START;\r\n        }\r\n\r\n        // expand end open list\r\n\r\n        node = endOpenList.shift();\r\n        node.closed = true;\r\n\r\n        neighbors = grid.getNeighbors(node, diagonalMovement);\r\n        for (i = 0, l = neighbors.length; i < l; ++i) {\r\n            neighbor = neighbors[i];\r\n\r\n            if (neighbor.closed) {\r\n                continue;\r\n            }\r\n            if (neighbor.opened) {\r\n                if (neighbor.by === BY_START) {\r\n                    return Util.biBacktrace(neighbor, node);\r\n                }\r\n                continue;\r\n            }\r\n            endOpenList.push(neighbor);\r\n            neighbor.parent = node;\r\n            neighbor.opened = true;\r\n            neighbor.by = BY_END;\r\n        }\r\n    }\r\n\r\n    // fail to find the path\r\n    return [];\r\n};\r\n\r\nmodule.exports = BiBreadthFirstFinder;\r\n","var BiAStarFinder = require('./BiAStarFinder');\r\n\r\n/**\r\n * Bi-directional Dijkstra path-finder.\r\n * @constructor\r\n * @extends BiAStarFinder\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n */\r\nfunction BiDijkstraFinder(opt) {\r\n    BiAStarFinder.call(this, opt);\r\n    this.heuristic = function(dx, dy) {\r\n        return 0;\r\n    };\r\n}\r\n\r\nBiDijkstraFinder.prototype = new BiAStarFinder();\r\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\r\n\r\nmodule.exports = BiDijkstraFinder;\r\n","var Util       = require('../core/Util');\r\nvar Heuristic  = require('../core/Heuristic');\r\nvar Node       = require('../core/Node');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Iterative Deeping A Star (IDA*) path-finder.\r\n *\r\n * Recursion based on:\r\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\r\n *\r\n * Path retracing based on:\r\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\r\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\r\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\r\n *\r\n * @author Gerard Meier (www.gerardmeier.com)\r\n *\r\n * @constructor\r\n * @param {Object} opt\r\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\r\n *     Deprecated, use diagonalMovement instead.\r\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\r\n *     block corners. Deprecated, use diagonalMovement instead.\r\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\r\n *     suboptimal paths, in order to speed up the search.\r\n * @param {boolean} opt.trackRecursion Whether to track recursion for\r\n *     statistical purposes.\r\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\r\n */\r\nfunction IDAStarFinder(opt) {\r\n    opt = opt || {};\r\n    this.allowDiagonal = opt.allowDiagonal;\r\n    this.dontCrossCorners = opt.dontCrossCorners;\r\n    this.diagonalMovement = opt.diagonalMovement;\r\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    this.weight = opt.weight || 1;\r\n    this.trackRecursion = opt.trackRecursion || false;\r\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\r\n\r\n    if (!this.diagonalMovement) {\r\n        if (!this.allowDiagonal) {\r\n            this.diagonalMovement = DiagonalMovement.Never;\r\n        } else {\r\n            if (this.dontCrossCorners) {\r\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\r\n            } else {\r\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\r\n            }\r\n        }\r\n    }\r\n\r\n    // When diagonal movement is allowed the manhattan heuristic is not\r\n    // admissible, it should be octile instead\r\n    if (this.diagonalMovement === DiagonalMovement.Never) {\r\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\r\n    } else {\r\n        this.heuristic = opt.heuristic || Heuristic.octile;\r\n    }\r\n}\r\n\r\n/**\r\n * Find and return the the path. When an empty array is returned, either\r\n * no path is possible, or the maximum execution time is reached.\r\n *\r\n * @return {Array<Array<number>>} The path, including both start and\r\n *     end positions.\r\n */\r\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\r\n    // Used for statistics:\r\n    var nodesVisited = 0;\r\n\r\n    // Execution time limitation:\r\n    var startTime = new Date().getTime();\r\n\r\n    // Heuristic helper:\r\n    var h = function(a, b) {\r\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\r\n    }.bind(this);\r\n\r\n    // Step cost from a to b:\r\n    var cost = function(a, b) {\r\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\r\n    };\r\n\r\n    /**\r\n     * IDA* search implementation.\r\n     *\r\n     * @param {Node} The node currently expanding from.\r\n     * @param {number} Cost to reach the given node.\r\n     * @param {number} Maximum search depth (cut-off value).\r\n     * @param {Array<Array<number>>} The found route.\r\n     * @param {number} Recursion depth.\r\n     *\r\n     * @return {Object} either a number with the new optimal cut-off depth,\r\n     * or a valid node instance, in which case a path was found.\r\n     */\r\n    var search = function(node, g, cutoff, route, depth) {\r\n        nodesVisited++;\r\n\r\n        // Enforce timelimit:\r\n        if (this.timeLimit > 0 &&\r\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\r\n            // Enforced as \"path-not-found\".\r\n            return Infinity;\r\n        }\r\n\r\n        var f = g + h(node, end) * this.weight;\r\n\r\n        // We've searched too deep for this iteration.\r\n        if (f > cutoff) {\r\n            return f;\r\n        }\r\n\r\n        if (node == end) {\r\n            route[depth] = [node.x, node.y];\r\n            return node;\r\n        }\r\n\r\n        var min, t, k, neighbour;\r\n\r\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\r\n\r\n        // Sort the neighbours, gives nicer paths. But, this deviates\r\n        // from the original algorithm - so I left it out.\r\n        //neighbours.sort(function(a, b){\r\n        //    return h(a, end) - h(b, end);\r\n        //});\r\n\r\n        \r\n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\r\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\r\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\r\n            if (this.trackRecursion) {\r\n                // Retain a copy for visualisation. Due to recursion, this\r\n                // node may be part of other paths too.\r\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\r\n\r\n                if(neighbour.tested !== true) {\r\n                    neighbour.tested = true;\r\n                }\r\n            }\r\n\r\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\r\n\r\n            if (t instanceof Node) {\r\n                route[depth] = [node.x, node.y];\r\n\r\n                // For a typical A* linked list, this would work:\r\n                // neighbour.parent = node;\r\n                return t;\r\n            }\r\n\r\n            // Decrement count, then determine whether it's actually closed.\r\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\r\n                neighbour.tested = false;\r\n            }\r\n\r\n            if (t < min) {\r\n                min = t;\r\n            }\r\n        }\r\n\r\n        return min;\r\n\r\n    }.bind(this);\r\n\r\n    // Node instance lookups:\r\n    var start = grid.getNodeAt(startX, startY);\r\n    var end   = grid.getNodeAt(endX, endY);\r\n\r\n    // Initial search depth, given the typical heuristic contraints,\r\n    // there should be no cheaper route possible.\r\n    var cutOff = h(start, end);\r\n\r\n    var j, route, t;\r\n\r\n    // With an overflow protection.\r\n    for (j = 0; true; ++j) {\r\n\r\n        route = [];\r\n\r\n        // Search till cut-off depth:\r\n        t = search(start, 0, cutOff, route, 0);\r\n\r\n        // Route not possible, or not found in time limit.\r\n        if (t === Infinity) {\r\n            return [];\r\n        }\r\n\r\n        // If t is a node, it's also the end node. Route is now\r\n        // populated with a valid path to the end node.\r\n        if (t instanceof Node) {\r\n            return route;\r\n        }\r\n\r\n        // Try again, this time with a deeper cut-off. The t score\r\n        // is the closest we got to the end node.\r\n        cutOff = t;\r\n    }\r\n\r\n    // This _should_ never to be reached.\r\n    return [];\r\n};\r\n\r\nmodule.exports = IDAStarFinder;\r\n","/**\r\n * @author aniero / https://github.com/aniero\r\n */\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\nvar JPFNeverMoveDiagonally = require('./JPFNeverMoveDiagonally');\r\nvar JPFAlwaysMoveDiagonally = require('./JPFAlwaysMoveDiagonally');\r\nvar JPFMoveDiagonallyIfNoObstacles = require('./JPFMoveDiagonallyIfNoObstacles');\r\nvar JPFMoveDiagonallyIfAtMostOneObstacle = require('./JPFMoveDiagonallyIfAtMostOneObstacle');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm\r\n * @param {Object} opt\r\n * @param {function} opt.heuristic Heuristic function to estimate the distance\r\n *     (defaults to manhattan).\r\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\r\n *      movement will be allowed.\r\n */\r\nfunction JumpPointFinder(opt) {\r\n    opt = opt || {};\r\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\r\n        return new JPFNeverMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\r\n        return new JPFAlwaysMoveDiagonally(opt);\r\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\r\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\r\n    } else {\r\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\r\n    }\r\n}\r\n\r\nmodule.exports = JumpPointFinder;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm allowing only horizontal\r\n * or vertical movements.\r\n */\r\nfunction JPFNeverMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    if (dx !== 0) {\r\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else if (dy !== 0) {\r\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        //When moving vertically, must check for horizontal jump points\r\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        if (dx !== 0) {\r\n            if (grid.isWalkableAt(x, y - 1)) {\r\n                neighbors.push([x, y - 1]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + 1)) {\r\n                neighbors.push([x, y + 1]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if (grid.isWalkableAt(x - 1, y)) {\r\n                neighbors.push([x - 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + 1, y)) {\r\n                neighbors.push([x + 1, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFNeverMoveDiagonally;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which always moves\r\n * diagonally irrespective of the number of obstacles.\r\n */\r\nfunction JPFAlwaysMoveDiagonally(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\r\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    return this._jump(x + dx, y + dy, x, y);\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y + dy)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x + 1, y)) {\r\n                    neighbors.push([x + 1, y + dy]);\r\n                }\r\n                if (!grid.isWalkableAt(x - 1, y)) {\r\n                    neighbors.push([x - 1, y + dy]);\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y + 1)) {\r\n                    neighbors.push([x + dx, y + 1]);\r\n                }\r\n                if (!grid.isWalkableAt(x, y - 1)) {\r\n                    neighbors.push([x + dx, y - 1]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFAlwaysMoveDiagonally;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there are no obstacles.\r\n */\r\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            // return [x, y];\r\n        // }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if (dx !== 0) {\r\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\r\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else if (dy !== 0) {\r\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\r\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\r\n                return [x, y];\r\n            }\r\n            // When moving vertically, must check for horizontal jump points\r\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\r\n                // return [x, y];\r\n            // }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            var isNextWalkable;\r\n            if (dx !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\r\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\r\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (isTopWalkable) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (isBottomWalkable) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n                if (isTopWalkable) {\r\n                    neighbors.push([x, y + 1]);\r\n                }\r\n                if (isBottomWalkable) {\r\n                    neighbors.push([x, y - 1]);\r\n                }\r\n            }\r\n            else if (dy !== 0) {\r\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\r\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\r\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\r\n\r\n                if (isNextWalkable) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (isRightWalkable) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (isLeftWalkable) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n                if (isRightWalkable) {\r\n                    neighbors.push([x + 1, y]);\r\n                }\r\n                if (isLeftWalkable) {\r\n                    neighbors.push([x - 1, y]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\r\n","/**\r\n * @author imor / https://github.com/imor\r\n */\r\nvar JumpPointFinderBase = require('./JumpPointFinderBase');\r\nvar DiagonalMovement = require('../core/DiagonalMovement');\r\n\r\n/**\r\n * Path finder using the Jump Point Search algorithm which moves\r\n * diagonally only when there is at most one obstacle.\r\n */\r\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\r\n    JumpPointFinderBase.call(this, opt);\r\n}\r\n\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n\r\n/**\r\n * Search recursively in the direction (parent -> child), stopping only when a\r\n * jump point is found.\r\n * @protected\r\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\r\n *     found, or null if not found\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\r\n    var grid = this.grid,\r\n        dx = x - px, dy = y - py;\r\n\r\n    if (!grid.isWalkableAt(x, y)) {\r\n        return null;\r\n    }\r\n\r\n    if(this.trackJumpRecursion === true) {\r\n        grid.getNodeAt(x, y).tested = true;\r\n    }\r\n\r\n    if (grid.getNodeAt(x, y) === this.endNode) {\r\n        return [x, y];\r\n    }\r\n\r\n    // check for forced neighbors\r\n    // along the diagonal\r\n    if (dx !== 0 && dy !== 0) {\r\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\r\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\r\n            return [x, y];\r\n        }\r\n        // when moving diagonally, must check for vertical/horizontal jump points\r\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\r\n            return [x, y];\r\n        }\r\n    }\r\n    // horizontally/vertically\r\n    else {\r\n        if( dx !== 0 ) { // moving along x\r\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\r\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n        else {\r\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\r\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\r\n                return [x, y];\r\n            }\r\n        }\r\n    }\r\n\r\n    // moving diagonally, must make sure one of the vertical/horizontal\r\n    // neighbors is open to allow the path\r\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\r\n        return this._jump(x + dx, y + dy, x, y);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Find the neighbors for the given node. If the node has a parent,\r\n * prune the neighbors based on the jump point search algorithm, otherwise\r\n * return all available neighbors.\r\n * @return {Array<Array<number>>} The neighbors found.\r\n */\r\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\r\n    var parent = node.parent,\r\n        x = node.x, y = node.y,\r\n        grid = this.grid,\r\n        px, py, nx, ny, dx, dy,\r\n        neighbors = [], neighborNodes, neighborNode, i, l;\r\n\r\n    // directed pruning: can ignore most neighbors, unless forced.\r\n    if (parent) {\r\n        px = parent.x;\r\n        py = parent.y;\r\n        // get the normalized direction of travel\r\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\r\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\r\n\r\n        // search diagonally\r\n        if (dx !== 0 && dy !== 0) {\r\n            if (grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x, y + dy]);\r\n            }\r\n            if (grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y]);\r\n            }\r\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\r\n                neighbors.push([x - dx, y + dy]);\r\n            }\r\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\r\n                neighbors.push([x + dx, y - dy]);\r\n            }\r\n        }\r\n        // search horizontally/vertically\r\n        else {\r\n            if(dx === 0) {\r\n                if (grid.isWalkableAt(x, y + dy)) {\r\n                    neighbors.push([x, y + dy]);\r\n                    if (!grid.isWalkableAt(x + 1, y)) {\r\n                        neighbors.push([x + 1, y + dy]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x - 1, y)) {\r\n                        neighbors.push([x - 1, y + dy]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (grid.isWalkableAt(x + dx, y)) {\r\n                    neighbors.push([x + dx, y]);\r\n                    if (!grid.isWalkableAt(x, y + 1)) {\r\n                        neighbors.push([x + dx, y + 1]);\r\n                    }\r\n                    if (!grid.isWalkableAt(x, y - 1)) {\r\n                        neighbors.push([x + dx, y - 1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // return all neighbors\r\n    else {\r\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\r\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\r\n            neighborNode = neighborNodes[i];\r\n            neighbors.push([neighborNode.x, neighborNode.y]);\r\n        }\r\n    }\r\n\r\n    return neighbors;\r\n};\r\n\r\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\r\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","import { Grid, BiBestFirstFinder, Heuristic, Util } from \"pathfinding\";\r\nimport { PathfindingModule, Obstacle } from \"./interfaces\";\r\n\r\nlet grid: Grid;\r\nlet finder: BiBestFirstFinder;\r\n\r\nasync function initPathfinding(): Promise<void> {\r\n  return Promise.resolve();\r\n}\r\n\r\nfunction startPathFinding(width: number, height: number): boolean {\r\n  grid = new Grid(width, height);\r\n  finder = new BiBestFirstFinder({\r\n    heuristic: Heuristic.octile,\r\n    //@ts-ignore\r\n    allowDiagonal: true,\r\n  });\r\n\r\n  return true;\r\n}\r\nfunction setObstacles(obstacles: Array<Obstacle>): boolean {\r\n  obstacles.forEach(({ x, y }) => {\r\n    grid.setWalkableAt(y, x, false);\r\n  });\r\n\r\n  return true;\r\n}\r\n\r\nfunction findPath(from: [number, number, number], to: [number, number, number]): Array<number[]> {\r\n  const path = finder.findPath(\r\n    Math.trunc(from[2] / 2),\r\n    Math.trunc(from[0] / 2),\r\n    Math.trunc(to[2] / 2),\r\n    Math.trunc(to[0] / 2),\r\n    grid.clone()\r\n  );\r\n\r\n  if (path.length === 0) {\r\n    return path;\r\n  }\r\n\r\n  return path; /*Util.smoothenPath(\r\n    grid,\r\n    path\r\n  );*/\r\n}\r\n\r\nfunction findPathAsync(from: [number, number, number], to: [number, number, number]): Promise<Array<number[]>> {\r\n  return new Promise((res) => {\r\n    res(findPath(from, to));\r\n  });\r\n}\r\n\r\nconst Module: PathfindingModule = {\r\n  initPathfinding,\r\n  startPathFinding,\r\n  setObstacles,\r\n  findPath,\r\n  findPathAsync,\r\n};\r\n\r\nexport default Module;\r\n","import Pathfinding from './js';\r\n\r\n/* eslint-disable no-restricted-globals */\r\nconst ctx: Worker = self as any;\r\n \r\n// Respond to message from parent thread\r\nctx.addEventListener(\"message\", (e) => {\r\n  if (!e.data.pathfinding) {\r\n    return;\r\n  }\r\n  const { operation, payload } = e.data.pathfinding;\r\n  switch (operation) {\r\n    case 'start':\r\n      Pathfinding.startPathFinding(payload.width, payload.height);\r\n      break;\r\n    case 'setObstacles':\r\n      Pathfinding.setObstacles(payload.obstacles);\r\n      break;\r\n    case 'findPath':\r\n      const path = Pathfinding.findPath(payload.from, payload.to);\r\n      ctx.postMessage({\r\n        pathfindingResult: {\r\n          operation: 'findPath',\r\n          result: path,\r\n        },\r\n      });\r\n      break;\r\n  }\r\n});\r\n\r\nexport default {} as typeof Worker & (new () => Worker);\r\n"],"sourceRoot":""}