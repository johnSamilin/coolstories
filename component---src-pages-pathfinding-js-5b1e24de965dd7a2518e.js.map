{"version":3,"sources":["webpack:///./src/components/profile-img-pathfinding-js.js","webpack:///./src/components/profile-img-pathfinding-threaded.js","webpack:///./src/components/profile-img-pathfinding-go.js","webpack:///./src/components/profile-img-pathfinding-as.js","webpack:///./src/pages/pathfinding.js"],"names":["ProfileImgPathfindingJs","src","data","fluid","placeholderImage","childImageSharp","ProfileImgPathfindingJsThreaded","ProfileImgPathfindingGo","ProfileImgPathfindingAs","Page","className","title","frameBorder","to"],"mappings":"k+DAIaA,EAA0B,SAAC,GAAY,EAAVC,IAAW,IAC7CC,EAAI,OAcV,OAAO,kBAAC,IAAD,CAAKC,MAAOD,EAAKE,iBAAiBC,gBAAgBF,S,YCf9CG,EAAkC,SAAC,GAAY,EAAVL,IAAW,IACrDC,EAAI,OAcV,OAAO,kBAAC,IAAD,CAAKC,MAAOD,EAAKE,iBAAiBC,gBAAgBF,S,YCf9CI,EAA0B,SAAC,GAAY,EAAVN,IAAW,IAC7CC,EAAI,OAcV,OAAO,kBAAC,IAAD,CAAKC,MAAOD,EAAKE,iBAAiBC,gBAAgBF,S,YCf9CK,EAA0B,SAAC,GAAY,EAAVP,IAAW,IAC7CC,EAAI,OAcV,OAAO,kBAAC,IAAD,CAAKC,MAAOD,EAAKE,iBAAiBC,gBAAgBF,SCmE5CM,UAzEF,kBACX,kBAAC,IAAD,CAAQC,UAAU,oBAChB,kBAAC,IAAD,CAAKC,MAAM,kBACX,4BAAQD,UAAU,QAChB,0CACA,yGAEF,4BACEA,UAAU,mBACVE,YAAY,IACZX,IAAI,iCAEN,iCACE,uBAAGS,UAAU,UAAb,kBACiB,kBAAC,OAAD,CAAMG,GAAG,WAAT,iBADjB,wDAC6G,kBAAC,OAAD,CAAMA,GAAG,6BAAT,UAD7G,kgBAEA,kCACA,guBAGA,uNAC2L,kBAAC,OAAD,CAAMA,GAAG,gDAAT,kBAD3L,wZAC6pB,kBAAC,OAAD,CAAMA,GAAG,sFAAT,kBAE7pB,2BACE,wEACA,kBAAC,EAAD,OAEF,+CACA,ydAC6b,kBAAC,OAAD,CAAMA,GAAG,4FAAT,UAD7b,gFAC2nB,yCAD3nB,KAC+oB,kBAAC,OAAD,CAAMA,GAAG,sGAAT,UAD/oB,MAGA,2BACE,4EACA,kBAAC,EAAD,OAEF,6CACA,kEACsC,kBAAC,OAAD,CAAMA,GAAG,8HAAT,qCADtC,wKACyX,kDADzX,0KAC+jB,2CAD/jB,sKAGA,sTAC0R,kBAAC,OAAD,CAAMA,GAAG,2EAAT,gBAD1R,2fAEE,4BACE,yNAGA,oKAGA,6KAIF,kBAAC,OAAD,CAAMA,GAAG,iDAAT,qBAEF,2BACE,wEACA,kBAAC,EAAD,OAEF,oCACA,oCACQ,iDADR,yMACyO,kBAAC,OAAD,CAAMA,GAAG,sDAAT,sCADzO,gBAC6V,0CAD7V,0JACugB,kBAAC,OAAD,CAAMA,GAAG,6DAAT,OADvgB,KAGA,2BACE,mFACA,kBAAC,EAAD,OAEF,uDACA,of","file":"component---src-pages-pathfinding-js-5b1e24de965dd7a2518e.js","sourcesContent":["import React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport Img from \"gatsby-image\"\n\nexport const ProfileImgPathfindingJs = ({ src }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      placeholderImage: file(\n        relativePath: { eq: \"profile-pathfinding-js.JPG\" }\n      ) {\n        childImageSharp {\n          fluid(maxWidth: 1920) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n    }\n  `)\n\n  return <Img fluid={data.placeholderImage.childImageSharp.fluid} />\n}\n","import React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport Img from \"gatsby-image\"\n\nexport const ProfileImgPathfindingJsThreaded = ({ src }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      placeholderImage: file(\n        relativePath: { eq: \"profile-pathfinding-threaded.JPG\" }\n      ) {\n        childImageSharp {\n          fluid(maxWidth: 1920) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n    }\n  `)\n\n  return <Img fluid={data.placeholderImage.childImageSharp.fluid} />\n}\n","import React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport Img from \"gatsby-image\"\n\nexport const ProfileImgPathfindingGo = ({ src }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      placeholderImage: file(\n        relativePath: { eq: \"profile-pathfinding-go.JPG\" }\n      ) {\n        childImageSharp {\n          fluid(maxWidth: 1920) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n    }\n  `)\n\n  return <Img fluid={data.placeholderImage.childImageSharp.fluid} />\n}\n","import React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport Img from \"gatsby-image\"\n\nexport const ProfileImgPathfindingAs = ({ src }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      placeholderImage: file(\n        relativePath: { eq: \"profile-pathfinding-as.JPG\" }\n      ) {\n        childImageSharp {\n          fluid(maxWidth: 1920) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n    }\n  `)\n\n  return <Img fluid={data.placeholderImage.childImageSharp.fluid} />\n}\n","import React from \"react\"\nimport { Link } from \"gatsby\"\nimport ReactRough, { Curve, Line } from \"react-rough\"\n\nimport Layout from \"../components/layout\"\nimport SEO from \"../components/seo\"\n\nimport \"./pathfinding.css\"\nimport { ProfileImgPathfindingJs } from \"../components/profile-img-pathfinding-js\"\nimport { ProfileImgPathfindingJsThreaded } from \"../components/profile-img-pathfinding-threaded\"\nimport { ProfileImgPathfindingGo } from \"../components/profile-img-pathfinding-go\"\nimport { ProfileImgPathfindingAs } from \"../components/profile-img-pathfinding-as\"\n\nconst Page = () => (\n  <Layout className=\"pathfinding-page\">\n    <SEO title=\"О поиске пути\" />\n    <header className=\"lead\">\n      <h1>Поиск пути</h1>\n      <summary>Это история о том, что свой путь можно найти несколькими способами.</summary>\n    </header>\n    <iframe\n      className=\"pathfinding-demo\"\n      frameBorder=\"0\"\n      src=\"/pathfinding-demo/index.html\"\n    />\n    <article>\n      <p className=\"letter\">\n        Когда я создал <Link to=\"/forest\">сцену с лесом</Link> и добавил туда персонажа (которого, кстати, взял на <Link to=\"https://www.mixamo.com/#/\">Mixamo</Link>), я подумал, что этот персонаж не может просто стоять на карте, как истукан, а должен уметь по ней передвигаться. Но не просто из точки А в точку Б, а с учетом препятствий. Раз уж наш пока что лирический герой находится в лесу, то должен уметь обходить деревья. Для меня это совершенно новый опыт и, возможно, люди, которые больше меня подкованы в теме разработки игр и алгоритмах, найдут этот текст дилетантским, но мне было интересно разбираться в том, как работает один из молотов, кующих разработчика, А*.</p>\n      <h2>A*</h2>\n      <p>\n        Если представить поверхность, по которой нужно перемещаться персонажу, сеткой, то поиск пути от одной клетки до другой - это задача поиска в графе. Один из самых оптимальных способов это сделать - применить алгоритм, которому уже 62 года. Представим, что у каждой клетки есть некоторая проходимость - чем сложнее по ней передвигаться, тем выше стоимость передвижения. Некоторые клетки (те, на которых есть деревья), вообще непроходмы. Задача А* - найти такой путь, который будет иметь минимальную стоимость, то есть будет самым быстрым. Для этого для каждой клетки дополнительно еще используется эвристическая оценка, которая показывает, насколько перспективным решением будет пойти в ту или иную сторону.\n      </p>\n      <p>\n        Раз уж так получилось, что я занимаюсь фронтендом и мне интересны возможности веб-платформы, самым логичным шагом было начать с javascript-имплементации. Существует отличная библиотека <Link to=\"http://qiao.github.io/PathFinding.js/visual/\">PathFinding.js</Link>, в которой собран десяток различных вариантов этого алгоритма и несколько видов эвристик. По ссылке можно посмотреть на статистику: сколько проходит итераций поиска, сколько он занимает времени. Самым оптимальным, на мой взгляд, был двунаправленный Best First Search с эвристикой Octile. Дополнительно он может свернуть путь до небольшого количества ключевых точек, определяющих, где находятся повороты. <Link to=\"https://github.com/johnSamilin/forest/blob/pathfinding/src/utils/pathfinding/js.ts\">Ссылка на код</Link>\n      </p>\n      <p>\n        <strong>Профиль производительности js-версии</strong>\n        <ProfileImgPathfindingJs />\n      </p>\n      <h2>А можно мощнее?</h2>\n      <p>\n        Javascript - штука однопоточная, и если иметь дело с большой или запутанной картой, вычисления могут повлиять на отзывчивость интерфейса. Браузер и без того занят тем, что выполняет кучу работы по визуализации сцены каждые 16 миллисекунд, и правильным решением было бы ему помочь. Например, вынеся задачу поиска пути в отдельный поток, в воркер. По идее, это должно освободить основной поток для выполнения и планирования более важной работы. <Link to=\"https://github.com/johnSamilin/forest/blob/pathfinding/src/utils/pathfinding/threaded.ts\">Ссылка</Link> на тот же самый код, что и в предыдущем примере, но уже перенесенный внурть <em>работника</em> (<Link to=\"https://github.com/johnSamilin/forest/blob/pathfinding/src/utils/pathfinding/pathfinding.worker.ts\">Github</Link>).\n      </p>\n      <p>\n        <strong>Профиль производительности worker-версии</strong>\n        <ProfileImgPathfindingJsThreaded />\n      </p>\n      <h2>А еще мощнее?</h2>\n      <p>\n        JS-версия, я уверен, использует все <Link to=\"https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e\">возможности движка по оптимизации</Link>, как например, hidden classes и кеширование, и при использовании TypeScript можно быть в той или иной степени уверенным в том, что параметры, передающиеся в методы <strong>PathFinding.js</strong>, будут всегда одного и того же типа. Это, в свою очередь, не будет приводить к их деоптимизации. Но еще интересней попробовать запустить этот процесс в WebAssembly с <em>near-native</em> скоростью. С точки зрения веб-технологий это еще более любопытно, потому что, несмотря на 10 лет своего существования, WebAssembly не используется так уж широко.\n      </p>\n      <p>\n        WebAssembly можно скомпилировать из десятка языков, включая C++, Go и Rust. Так как я не умею писать ни на одном из них, то можно просто найти готовое решение и скомпилировать его под свои нужды. Я выбрал Go, потому что... не знаю, просто попробовать. Благодаря отличному разбору <Link to=\"https://www.aaron-powell.com/posts/2019-02-05-golang-wasm-2-writing-go/\">Aaron Powell</Link>, все оказалось не так уж и сложно и заняло буквально один день. Штука в том (и об этом есть упоминание в статье), что Wasm, скомпилированный из Go, ведет себя как отдельная подпрограмма. В ней можно использовать состояние и не инициализировать граф с препятствиями при каждом вызове. Учитывая, что в конкретно этой моей WebGL-сцене поиск пути выполняется при движении мыши над плоскостью, это может сэкономить некоторое количество ресурсов. Хотя этот же факт может привести к нежелательным последствиям:\n        <ul>\n          <li>\n            исключение, выброшенное внутри Wasm-модуля, означает, что поток, который не дает Go-скрипту завершиться, закрывается и повторная попытка вызвать какие-то из его функций будет неудачной;\n          </li>\n          <li>\n            Go не экспортирует никаких функций, он регистрирует обработчики в глобальной области видимости. Это может привести к конфликту имен;\n          </li>\n          <li>\n            то, что через все ту же глобальную область видимости он может манипулировать DOM, на мой взгляд, делает Go потенциально небезопасной штукой.\n          </li>\n        </ul>\n        <Link to=\"https://github.com/johnSamilin/go-pathfinding\">Go-имплементация</Link>\n      </p>\n      <p>\n        <strong>Профиль производительности go-версии</strong>\n        <ProfileImgPathfindingGo />\n      </p>\n      <h2>Еще!</h2>\n      <p>\n        Чтобы <del>совсем упороться</del> не пренебрегать возможностями Wasm по управлению памятью, я решил пойти на эксперимент и написать рализацию А* самому на AssmeblyScript. Это версия TypeScript с чуть более строгими ограничениями и <Link to=\"https://www.assemblyscript.org/stdlib/map.html#map\">разницей в поведении базовых типов</Link> (к примеру, <em>Map.keys()</em> возвращает не итератор, а массив ключей). В случае чего, AssmeblyScript-код можно довольно быстро преобразовать в TypeScript. Увидеть результат можно <Link to=\"https://github.com/johnSamilin/assemblyscript-pathfinding\">тут</Link>.\n      </p>\n      <p>\n        <strong>Профиль производительности AssembyScript-версии</strong>\n        <ProfileImgPathfindingAs />\n      </p>\n      <h2>Как теперь с этим жить?</h2>\n      <p>\n        Я надеялся, что простая миграция миграция кода с уровня браузера на уровен WebAssembly даст прирость производительности и избавит от головной боли по оптимизации. Но, как видно из скриншотов профилировщика, большой разницы нет. Wasm-версии работают даже немного хуже в периоды интенсивной деятельности. FPS снижается иногда до 1-2 кадров в секунду, и в это время сильно нагружен GPU. Эксперимент завершился, самый правильный выбор - полагаться на браузерный движок.\n      </p>\n    </article>\n  </Layout>\n)\n\nexport default Page\n"],"sourceRoot":""}