(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{"9k6k":function(e,t,a){"use strict";a.r(t);var n=a("q1tI"),r=a.n(n),o=a("Wbzz"),l=a("fMzE"),s=a("JYhW"),c=a("xj1T"),i=a.n(c),m=a("Bl7J"),d=a("vrFN"),h=a("W/9C");a("H9hG"),a("JDK3");t.default=function(){return r.a.createElement(m.a,{lang:"en",className:"strategy-page",path:"strategy"},r.a.createElement(d.a,{title:"About crowd management"}),r.a.createElement("header",{className:"lead"},r.a.createElement("h1",null,"Crowd management"),r.a.createElement("summary",null,"Game developement is funny. Especially for the one who does regular frontend like me for example. For someone who thinks in other categories and architectural patterns.")),r.a.createElement(s.a,{brackets:"bottom",show:!0,type:"bracket",roughness:1,color:"red"},r.a.createElement("article",null,r.a.createElement("p",null,"Like, how do you move the players model and syncronize its movement with the steps animation so that the leg does not slide the surface but stays in place until the next step?",r.a.createElement("div",{id:"path-illustration"},r.a.createElement(l.e,{width:720,height:600,renderer:"svg"},r.a.createElement(l.c,{roughness:1,d:"M656.548,228.571C630.357,228.571 629.167,253.571 630.357,254.762C631.548,255.952 629.167,271.429 649.405,276.19C669.643,280.952 682.738,270.238 685.119,255.952C687.5,241.667 638.69,189.286 660.119,309.524C681.548,429.762 714.881,380.952 681.548,390.476C648.214,400 696.7,412.502 669.481,350.299C642.262,288.095 536.31,310.714 672.024,309.524C807.738,308.333 700.595,307.143 724.405,309.524C748.214,311.905 649.081,304.169 669.481,350.299"}),r.a.createElement(l.c,{stroke:"black",d:"M684.935,407.755C684.935,407.755 655.983,506.04 588.173,508.326C520.364,510.612 447.221,378.802 454.84,392.516C462.459,406.231 396.174,275.945 298.65,367.374C201.126,458.802 188.174,230.993 185.888,212.707C183.602,194.421 195.793,8.517 340.555,130.421"}),r.a.createElement(l.c,{stroke:"black",d:"M329.507,130.97L340.851,130.97L340.851,120.744"}),r.a.createElement(l.c,{stroke:"red",d:"M604.173,487.755L626.269,509.85L616.364,499.945L632.364,483.945L603.411,512.897"}),r.a.createElement(l.c,{stroke:"red",d:"M466.269,430.612L501.316,430.612L484.554,430.612L484.554,415.374L484.554,445.088"}),r.a.createElement(l.c,{stroke:"red",d:"M364.935,320.897L395.412,351.374L379.924,335.886L394.417,321.393L366.081,349.729"}),r.a.createElement(l.c,{stroke:"red",d:"M244.371,375.819L269.836,401.284L257.478,388.926L270.71,375.694L245.494,400.91"}),r.a.createElement(l.c,{stroke:"red",d:"M171.969,203.303L201.429,203.303L185.95,203.303L182.455,190.57L190.195,212.541"}),r.a.createElement(l.c,{stroke:"rgb(235,235,235)",d:"M683.976,407.675L617.538,500.322L484.662,432.056L379.824,336.97L259.139,388.779L185.996,204.094L340.815,130.342"})))," We have the path to go, the model to animate and the ground. But how do you rotate the character in the right direction? If he went in the straight line you could just rotate him in the direction of the last point. But path a is broken curve and if you do so, he will go crab-like.",r.a.createElement("br",null),r.a.createElement("br",null),"Some might say that you could rotate the player every time he reaches the next path control point. But that won't give you suitable result because he will be rotated too fast. After days of experiments and searching I found the solution (",r.a.createElement(o.Link,{to:"https://github.com/mrdoob/three.js/issues/743"},"How to move objects along a spline"),"): place a Besier curve through all the control points and re-face the player model as is moves. Now you can see smooth cool movement (with some bugs, but let's don't talk about it)."),r.a.createElement("p",null,"Yay! But there is a spoon of tar: three.js animations don't play by themselves, you should imperatively control them by using"," ",r.a.createElement(o.Link,{to:"https://threejs.org/docs/index.html#api/en/core/Clock"},"Clock")," ","object. And it works bad if there is a lot of work to be done in the scene: if you rotate the camera in the process, the animation will stuck. It definately great for animating unnesessary objects, but not the player object. In order to make this task super-duper-priority, I wrote custom implementation using webworker.",r.a.createElement("br",null),r.a.createElement(o.Link,{to:"https://github.com/johnSamilin/forest/commit/c272188c5fb6c7f17a223df6067b68c07c690c50#diff-7ab582f544ca56c9375ffb3cb4e7e8cbeb3dca29aabe63205f81e34c415f56c1R1"},"Full code"),"."))),r.a.createElement("div",{class:"gif-wrapper"},r.a.createElement("img",{loading:"lazy",src:"/images/useFrame.gif",alt:"Movement without worker"}),r.a.createElement("div",{className:"code"},r.a.createElement(i.a,{className:"javascript"},"const ctx: Worker = self as any;\n \n let lastTime: number;\n let scheduleNextCall = true;\n \n function tick() {\n   const currentTime = performance.now();\n   ctx.postMessage({\n     useFrame: {\n       delta: (currentTime - lastTime) / 1000, // in seconds\n     },\n   });\n   lastTime = currentTime;\n   if (scheduleNextCall) {\n     requestAnimationFrame(tick);\n   }\n }\n \n // Respond to message from parent thread\n ctx.addEventListener('message', (e) => {\n   if (!e.data.useFrame) {\n     return;\n   }\n   if (e.data.useFrame.enabled) {\n     scheduleNextCall = true;\n     lastTime = performance.now();\n     tick();\n   } else {\n     scheduleNextCall = false;\n   }\n });")),r.a.createElement("img",{loading:"lazy",src:"/images/useWorker.gif",alt:"Movement with worker"})),r.a.createElement(s.a,{brackets:["top","bottom"],show:!0,type:"bracket",roughness:1,color:"red"},r.a.createElement("article",null,r.a.createElement("p",null,"After some confession I"," ",r.a.createElement(o.Link,{to:"https://github.com/johnSamilin/forest/commit/f088c3b76a487ca26f0b4d96dca636b73b354da3#diff-3d74dddefb6e35fbffe3c76ec0712d5c416352d9449e2fcc8210a9dee57dff67R52"},"decided to add some more characters."),r.a.createElement("br",null),r.a.createElement("br",null),"Архитектура react диктует императивный подход к управлению: когда компонент, представляющий игрока, получает новый путь, то он, как истинный самурай, реагирует запуском анимаций и передвижением по нему. Это свойство передает ему родительский компонент, так что, если в момент передвижения одной фигурки задать маршрут для другой, то все сразу сломается. Думаю, в нормальных движках с ООП-подходом такие вещи разрешаются легко и просто, но в проекте, где используется react-three-fiber, нужно исходить из принятых шаблонов. И самым логичным было бы выделение общего менеджера, который бы управлял NPC, как кукловод. На роль такого менеджера неплохо подошел Redux. React architecture forces to use imperative management: when a component receives a new path it reacts with starting animations and moving the model along the way. This property is being passed by the parent component so if it changes during the movement, the will be big badaboom. I'm sure this doesn't take place in mature game engines but as long as I use react-three-fiber, I need to follow the rules. I needed some manager which could manipulate the models like a puppeteer. The most suitable solution is to use Redux.",r.a.createElement("div",{className:"code"},r.a.createElement(i.a,{className:"javascript"},"const [activePlayer, setActivePlayer] = useState('oldman');\n                 \n const [playersState, dispatch] = useReducer(playersReducer, {\n   movement: playerIds.reduce((acc, id) => ({ ...acc, [id]: null }), {}),\n   position: playerIds.reduce((acc, id, index) => ({ ...acc, [id]: [25 + index, 0, 25 + index] }), {}),\n });\n \n function handleFloorClick(e) {\n   e.stopPropagation();\n   if (isWorkerBusy) {\n     return;\n   }\n   dispatch(movePlayer(activePlayer, path));\n }\n \n <Context.Provider value={{ dispatch, playersState }}> \n   {playerIds.map((id) => <Character \n     id={id} \n     position={playersState.position[id]} \n     model=\"player/Manequin\" \n     isSelected={activePlayer === id} \n   />)} \n </Context.Provider>                ")),"Now the game controller is searching the path and passes it to selected unit. It, in turn, notifies the cotroller about the fact that it reached the end.",r.a.createElement("br",null),r.a.createElement("br",null),"Finally, when each NPC can move it's own way, I should probably teach them to go together. Just find the path for each of the selected characters separately if the final point is reachable.",r.a.createElement("br",null),r.a.createElement("br",null),"There is a ",r.a.createElement(o.Link,{to:"/strategy-demo"},"demo scene")," where you can try it in action. Hold left shift button to select more than one NPC."),r.a.createElement("div",{className:"date"},"21 february 2021"),r.a.createElement(h.a,{lang:"en"}))),r.a.createElement("div",{class:"gif-wrapper"},r.a.createElement("img",{loading:"lazy",src:"/images/separate-walk.gif",alt:"Передвижение по отдельности"}),r.a.createElement("img",{loading:"lazy",src:"/images/group-walk.gif",alt:"Передвижение группой"}),r.a.createElement("img",{loading:"lazy",src:"/images/bracket.gif",alt:"Выделение группы"})))}}}]);
//# sourceMappingURL=component---src-pages-en-strategy-js-3568d8b2ba5cd8f112ef.js.map