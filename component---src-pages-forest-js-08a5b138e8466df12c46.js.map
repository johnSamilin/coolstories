{"version":3,"sources":["webpack:///./src/components/index-lead.js","webpack:///./src/pages/forest.js"],"names":["ImageIndexLead","src","data","fluid","placeholderImage","childImageSharp","IndexPage","className","path","lang","title","frameBorder","to","width","height","config","options","roughness","points","stroke","x1","x2","y1","y2"],"mappings":"0gFAeaA,EAAiB,SAAC,GAAY,EAAVC,IAAW,IACpCC,EAAI,OAcV,OAAO,kBAAC,IAAD,CAAKC,MAAOD,EAAKE,iBAAiBC,gBAAgBF,S,wBCiI5CG,UApJG,kBAChB,kBAAC,IAAD,CAAQC,UAAU,cAAcC,KAAK,UACnC,kBAAC,IAAD,CAAKC,KAAK,KAAKC,MAAM,kCACrB,yBAAKH,UAAU,QACb,kBAAC,EAAD,MACA,mCACA,uFAEF,iCACE,4BACEA,UAAU,cACVI,YAAY,IACZV,IAAI,6BAEN,yQAMA,oRAImD,IACjD,kBAAC,OAAD,CAAMW,GAAG,uCAAT,qBALF,oKAQoB,IAClB,kBAAC,OAAD,CAAMA,GAAG,gDAAT,kCATF,mHAa4C,IAC1C,kBAAC,OAAD,CAAMA,GAAG,mFAAT,eAdF,KAmBA,6CACA,iFACsD,IACpD,iDAFF,kEAKA,0GAGE,4BACE,gCACG,kCADH,qCAGA,gCACG,kCADH,6CAGA,gCACG,kCADH,0DAGA,gCACG,kCADH,gCAGA,gCACG,kCADH,oDAhBJ,wDAoBuD,kCApBvD,kIAuBE,4BACE,8CACA,+CACA,kDAGJ,kTAIuE,IACrE,gDALF,uCAKiE,IAC/D,kBAAC,OAAD,CAAMA,GAAG,gBAAT,eANF,8BAQA,uBAAGL,UAAU,UACX,yBAAKN,IAAI,6BAEX,+JAE2D,IACzD,oDAHF,2DAIiB,uCAJjB,gIAQA,2CACA,4LAGkB,mCAHlB,6MAQA,qZAM8B,kCAN9B,iFAOuD,IACrD,uDARF,yBAUA,yBAAKM,UAAU,WACb,uBAAGA,UAAU,UACX,yBAAKN,IAAI,kCAEX,kBAAC,IAAD,CACEY,MAAO,IACPC,OAAQ,IACRC,OAAQ,CACNC,QAAS,CACPC,UAAW,KAIf,kBAAC,IAAD,CACEC,OAAQ,CACN,CAAC,GAAI,GACL,CAAC,IAAK,IACN,CAAC,GAAI,KACL,CAAC,GAAI,MAEPC,OAAO,QAET,kBAAC,IAAD,CAAMC,GAAI,GAAIC,GAAI,GAAIC,GAAI,IAAKC,GAAI,IAAKJ,OAAO,QAC/C,kBAAC,IAAD,CAAMC,GAAI,GAAIC,GAAI,GAAIC,GAAI,IAAKC,GAAI,IAAKJ,OAAO,SAEjD,uBAAGZ,UAAU,UACX,yBAAKN,IAAI,8BAGb,iEACA,uBAAGM,UAAU,QAAb,eACA,kBAAC,IAAD","file":"component---src-pages-forest-js-08a5b138e8466df12c46.js","sourcesContent":["import React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport Img from \"gatsby-image\"\n\n/*\n * This component is built using `gatsby-image` to automatically serve optimized\n * images with lazy loading and reduced file sizes. The image is loaded using a\n * `useStaticQuery`, which allows us to load the image from directly within this\n * component, rather than having to pass the image data down from pages.\n *\n * For more information, see the docs:\n * - `gatsby-image`: https://gatsby.dev/gatsby-image\n * - `useStaticQuery`: https://www.gatsbyjs.org/docs/use-static-query/\n */\n\nexport const ImageIndexLead = ({ src }) => {\n  const data = useStaticQuery(graphql`\n    query {\n      placeholderImage: file(\n        relativePath: { eq: \"les-krasivye-kartinki-na-rabochij-stol-2.jpg\" }\n      ) {\n        childImageSharp {\n          fluid(maxWidth: 1920) {\n            ...GatsbyImageSharpFluid\n          }\n        }\n      }\n    }\n  `)\n\n  return <Img fluid={data.placeholderImage.childImageSharp.fluid} />\n}\n","import React from \"react\"\nimport { Link } from \"gatsby\"\nimport ReactRough, { Curve, Line } from \"react-rough\"\n\nimport Layout from \"../components/layout\"\nimport SEO from \"../components/seo\"\nimport { ImageIndexLead } from \"../components/index-lead\"\n\nimport \"./forest.css\"\nimport { Footer } from \"../components/footer\"\n\nconst IndexPage = () => (\n  <Layout className=\"forest-page\" path=\"forest\">\n    <SEO lang=\"ru\" title=\"О процедурной генерации лесов\" />\n    <div className=\"lead\">\n      <ImageIndexLead />\n      <h1>Лес</h1>\n      <summary>Это история о том, как вырастить лес. В браузере.</summary>\n    </div>\n    <article>\n      <iframe\n        className=\"tree-on-box\"\n        frameBorder=\"0\"\n        src=\"/tree-on-cube/index.html\"\n      />\n      <p>\n        Предположим, вы хотите создать игру, действие которой происходит в лесу.\n        Или же просто игру, в которой есть лесной массив. Как это сделать? Самый\n        дешевый способ - сгенерировать случайное распределение деревьев по\n        заданной поверхности.\n      </p>\n      <p>\n        Однажды, когда я был за городом, я много времени провел в лесу и мне не\n        давала покоя мысль: как сымитировать его случайность? В лесу все\n        хаотично, но при этом взаимосвязано. Тогда я провел небольше\n        исследование и нашел отличную статью Уэсли Керра{\" \"}\n        <Link to=\"https://www.wesley-kerr.com/forest/\">о генерации лесов</Link>.\n        Я не буду делать перевод этой статьи, однако, она довольно простая и\n        интересная, и она точно стоит того, чтобы ознакомиться. Или, например, с\n        этими работами по{\" \"}\n        <Link to=\"http://pcg.wikidot.com/pcg-algorithm:forests\">\n          процедурной генерации растений\n        </Link>\n        . Основываясь на этой работе я сделал порт кода в javascript и вот что\n        из этого вышло. Результат можно увидеть в{\" \"}\n        <Link to=\"https://github.com/johnSamilin/forest/blob/develop/src/utils/ForestGenerator.ts\">\n          репозитории\n        </Link>\n        .\n      </p>\n      <h2>Камера, мотор</h2>\n      <p>\n        Представим, что у нас есть уже настроенная сцена на{\" \"}\n        <em>react-three-fiber</em>: равнина, которую предстоит засеять\n        деревьями, камера и свет.\n      </p>\n      <p>\n        Как следует из статьи, работа алгоритма имитации леса зависит от\n        параметров:\n        <ul>\n          <li>\n            n<sub>f</sub> - начальное количество деревьев.\n          </li>\n          <li>\n            R<sub>s</sub> - радиус, внутри которого падают семена.\n          </li>\n          <li>\n            S<sub>s</sub> - количество семян, которые падают в каждой итерации.\n          </li>\n          <li>\n            d<sub>s</sub> - вероятность гибели семян.\n          </li>\n          <li>\n            F<sub>c</sub> - желаемый уровень покрытия поверхности лесом.\n          </li>\n        </ul>\n        Изначально разбрасываем по полю несколько деревьев (n<sub>f</sub>),\n        затем повторяем этап роста столько раз, сколько потребуется для\n        желаемого уровня покрытия. Каждый этап роста сопровождается:\n        <ol>\n          <li>падением семян</li>\n          <li>ростом деревьем</li>\n          <li>гибелью семян :(</li>\n        </ol>\n      </p>\n      <p>\n        Хорошо, алгоритм работает. И результатом его работы является матрица с\n        числами от 1 до 3 и массив координат, на которых должны располагаться\n        деревья. Зачем нам матрица, спросите вы. Затем, что она показывает\n        проходимые (пусто) и непроходимые (дерево) области, а мы хотим знать{\" \"}\n        <del>где сидит фазан</del> это, чтобы использовать в алгоритме{\" \"}\n        <Link to=\"/pathfinding\">поиска пути</Link>. Итак, что же получилось?\n      </p>\n      <p className=\"screen\">\n        <img src=\"/images/trees-close.PNG\" />\n      </p>\n      <p>\n        Выглядит не очень. Все потому, что трехмерные объекты обладают размерами\n        и нужно с этим считаться. Предположим, что каждая ячейка{\" \"}\n        <em>матрицы проходимости</em> представляет собой ячейку поверхности в\n        сцене размером <strong>NxN</strong>. Тогда для того, чтобы получить\n        реальные координаты дерева, нужно просто умножить их на N. Но все равно\n        чего-то не хватает.\n      </p>\n      <h2>Точки опоры</h2>\n      <p>\n        Когда вы хотите расположить объект в трехмерной сцене в точке [0, 0, 0],\n        где вы ожидаете его увидеть? Если это окно браузера, то, вероятно, в\n        углу плоскости. <em>Нет</em>. Центр системы координат в такой сцене\n        совпадает с центром плоскости, и для того, чтобы правильно разместить\n        лес по поверхности, нужно вычесть из координат каждого дерева &frac14;\n        ширины или длины плоскости.\n      </p>\n      <p>\n        Теперь у нас две проблемы. Во-первых, деревья расположены так, как\n        должны, за одним исключением. Часть из них, те, что растут густо,\n        выстроились в ровные ряды, как будто их сажали юннаты. Во-вторых, все\n        они одного возраста и роста. За возраст можно взять то количество циклов\n        генерации, которое \"прожило\" дерево. От него может зависеть его рост и\n        количество падающих семян (S<sub>s</sub>). Это не совсем то, чего\n        ожидаешь от дикой природы, так что давайте добавим в{\" \"}\n        <em>случайное распределение</em> элемент случайности.\n      </p>\n      <div className=\"compare\">\n        <p className=\"screen\">\n          <img src=\"/images/trees-translated.PNG\" />\n        </p>\n        <ReactRough\n          width={110}\n          height={160}\n          config={{\n            options: {\n              roughness: 2,\n            },\n          }}\n        >\n          <Curve\n            points={[\n              [50, 0],\n              [100, 20],\n              [20, 100],\n              [50, 150],\n            ]}\n            stroke=\"red\"\n          />\n          <Line x1={50} x2={50} y1={125} y2={150} stroke=\"red\" />\n          <Line x1={50} x2={30} y1={150} y2={150} stroke=\"red\" />\n        </ReactRough>\n        <p className=\"screen\">\n          <img src=\"/images/trees-final.PNG\" />\n        </p>\n      </div>\n      <p>И получим вполне реалистичный лес.</p>\n      <p className=\"date\">1 июля 2020</p>\n      <Footer />\n    </article>\n  </Layout>\n)\n\nexport default IndexPage\n"],"sourceRoot":""}