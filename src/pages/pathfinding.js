import React from "react"
import { Link } from "gatsby"
import ReactRough, { Curve, Line } from "react-rough"

import Layout from "../components/layout"
import SEO from "../components/seo"

import "./pathfinding.css"
import { ProfileImgPathfindingJs } from "../components/profile-img-pathfinding-js"
import { ProfileImgPathfindingJsThreaded } from "../components/profile-img-pathfinding-threaded"
import { ProfileImgPathfindingGo } from "../components/profile-img-pathfinding-go"
import { ProfileImgPathfindingAs } from "../components/profile-img-pathfinding-as"
import { Footer } from "../components/footer"

const Page = () => (
  <Layout className="pathfinding-page">
    <SEO title="О поиске пути" />
    <header className="lead">
      <h1>Поиск пути</h1>
      <summary>Это история о том, что свой путь можно найти несколькими способами.</summary>
    </header>
    <iframe
      className="pathfinding-demo"
      frameBorder="0"
      src="/pathfinding-demo/index.html"
    />
    <article>
      <p className="letter">
        Когда я создал <Link to="/forest">сцену с лесом</Link> и добавил туда персонажа (которого, кстати, взял на <Link to="https://www.mixamo.com/#/">Mixamo</Link>), я подумал, что этот персонаж не может просто стоять на карте, как истукан, а должен уметь по ней передвигаться. Но не просто из точки А в точку Б, а с учетом препятствий. Раз уж наш пока что лирический герой находится в лесу, то должен уметь обходить деревья. Для меня это совершенно новый опыт и, возможно, люди, которые больше меня подкованы в теме разработки игр и алгоритмах, найдут этот текст дилетантским, но мне было интересно разбираться в том, как работает один из молотов, кующих разработчика, А*.</p>
      <h2>A*</h2>
      <p>
        Если представить поверхность, по которой нужно перемещаться персонажу, сеткой, то поиск пути от одной клетки до другой - это задача поиска в графе. Один из самых оптимальных способов это сделать - применить алгоритм, которому уже 62 года. Представим, что у каждой клетки есть некоторая проходимость - чем сложнее по ней передвигаться, тем выше стоимость передвижения. Некоторые клетки (те, на которых есть деревья), вообще непроходмы. Задача А* - найти такой путь, который будет иметь минимальную стоимость, то есть будет самым быстрым. Для этого для каждой клетки дополнительно еще используется эвристическая оценка, которая показывает, насколько перспективным решением будет пойти в ту или иную сторону.
      </p>
      <p>
        Раз уж так получилось, что я занимаюсь фронтендом и мне интересны возможности веб-платформы, самым логичным шагом было начать с javascript-имплементации. Существует отличная библиотека <Link to="http://qiao.github.io/PathFinding.js/visual/">PathFinding.js</Link>, в которой собран десяток различных вариантов этого алгоритма и несколько видов эвристик. По ссылке можно посмотреть на статистику: сколько проходит итераций поиска, сколько он занимает времени. Самым оптимальным, на мой взгляд, был двунаправленный Best First Search с эвристикой Octile. Дополнительно он может свернуть путь до небольшого количества ключевых точек, определяющих, где находятся повороты. <Link to="https://github.com/johnSamilin/forest/blob/pathfinding/src/utils/pathfinding/js.ts">Ссылка на код</Link>
      </p>
      <p>
        <strong>Профиль производительности js-версии</strong>
        <ProfileImgPathfindingJs />
      </p>
      <h2>А можно мощнее?</h2>
      <p>
        Javascript - штука однопоточная, и если иметь дело с большой или запутанной картой, вычисления могут повлиять на отзывчивость интерфейса. Браузер и без того занят тем, что выполняет кучу работы по визуализации сцены каждые 16 миллисекунд, и правильным решением было бы ему помочь. Например, вынеся задачу поиска пути в отдельный поток, в воркер. По идее, это должно освободить основной поток для выполнения и планирования более важной работы. <Link to="https://github.com/johnSamilin/forest/blob/pathfinding/src/utils/pathfinding/threaded.ts">Ссылка</Link> на тот же самый код, что и в предыдущем примере, но уже перенесенный внурть <em>работника</em> (<Link to="https://github.com/johnSamilin/forest/blob/pathfinding/src/utils/pathfinding/pathfinding.worker.ts">Github</Link>).
      </p>
      <p>
        <strong>Профиль производительности worker-версии</strong>
        <ProfileImgPathfindingJsThreaded />
      </p>
      <h2>А еще мощнее?</h2>
      <p>
        JS-версия, я уверен, использует все <Link to="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e">возможности движка по оптимизации</Link>, как например, hidden classes и кеширование, и при использовании TypeScript можно быть в той или иной степени уверенным в том, что параметры, передающиеся в методы <strong>PathFinding.js</strong>, будут всегда одного и того же типа. Это, в свою очередь, не будет приводить к их деоптимизации. Но еще интересней попробовать запустить этот процесс в WebAssembly с <em>near-native</em> скоростью. С точки зрения веб-технологий это еще более любопытно, потому что, несмотря на 10 лет своего существования, WebAssembly не используется так уж широко.
      </p>
      <p>
        WebAssembly можно скомпилировать из десятка языков, включая C++, Go и Rust. Так как я не умею писать ни на одном из них, то можно просто найти готовое решение и скомпилировать его под свои нужды. Я выбрал Go, потому что... не знаю, просто попробовать. Благодаря отличному разбору <Link to="https://www.aaron-powell.com/posts/2019-02-05-golang-wasm-2-writing-go/">Aaron Powell</Link>, все оказалось не так уж и сложно и заняло буквально один день. Штука в том (и об этом есть упоминание в статье), что Wasm, скомпилированный из Go, ведет себя как отдельная подпрограмма. В ней можно использовать состояние и не инициализировать граф с препятствиями при каждом вызове. Учитывая, что в конкретно этой моей WebGL-сцене поиск пути выполняется при движении мыши над плоскостью, это может сэкономить некоторое количество ресурсов. Хотя этот же факт может привести к нежелательным последствиям:
        <ul>
          <li>
            исключение, выброшенное внутри Wasm-модуля, означает, что поток, который не дает Go-скрипту завершиться, закрывается и повторная попытка вызвать какие-то из его функций будет неудачной;
          </li>
          <li>
            Go не экспортирует никаких функций, он регистрирует обработчики в глобальной области видимости. Это может привести к конфликту имен;
          </li>
          <li>
            то, что через все ту же глобальную область видимости он может манипулировать DOM, на мой взгляд, делает Go потенциально небезопасной штукой.
          </li>
        </ul>
        <Link to="https://github.com/johnSamilin/go-pathfinding">Go-имплементация</Link>
      </p>
      <p>
        <strong>Профиль производительности go-версии</strong>
        <ProfileImgPathfindingGo />
      </p>
      <h2>Еще!</h2>
      <p>
        Чтобы <del>совсем упороться</del> не пренебрегать возможностями Wasm по управлению памятью, я решил пойти на эксперимент и написать рализацию А* самому на AssmeblyScript. Это версия TypeScript с чуть более строгими ограничениями и <Link to="https://www.assemblyscript.org/stdlib/map.html#map">разницей в поведении базовых типов</Link> (к примеру, <em>Map.keys()</em> возвращает не итератор, а массив ключей). В случае чего, AssmeblyScript-код можно довольно быстро преобразовать в TypeScript. Увидеть результат можно <Link to="https://github.com/johnSamilin/assemblyscript-pathfinding">тут</Link>.
      </p>
      <p>
        <strong>Профиль производительности AssembyScript-версии</strong>
        <ProfileImgPathfindingAs />
      </p>
      <h2>Как теперь с этим жить?</h2>
      <p>
        Я надеялся, что простая миграция миграция кода с уровня браузера на уровен WebAssembly даст прирость производительности и избавит от головной боли по оптимизации. Но, как видно из скриншотов профилировщика, большой разницы нет. Wasm-версии работают даже немного хуже в периоды интенсивной деятельности. FPS снижается иногда до 1-2 кадров в секунду, и в это время сильно нагружен GPU. Эксперимент завершился, самый правильный выбор - полагаться на браузерный движок.
      </p>
      <h3>Update</h3>
      <p>
        Простые <Link to="https://github.com/johnSamilin/assemblyscript-pathfinding/pull/1">оптимизации сборки</Link> могут ускорить WebAssembly-версию в 4 раза. ¯\_(ツ)_/¯
      </p>
      <h3>P.S.</h3>
      <p>
        <br/>
        Да, я знаю, он никуда не идет. Но ведь они никуда и не спешит :)
      </p>
      <p className="date">
        13 июля 2020
      </p>
      <Footer />
    </article>
  </Layout>
)

export default Page
