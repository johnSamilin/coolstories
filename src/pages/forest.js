import React from "react"
import { Link } from "gatsby"
import ReactRough, { Curve, Line } from "react-rough"

import Layout from "../components/layout"
import SEO from "../components/seo"
import { ImageIndexLead } from "../components/index-lead"

import "./forest.css"
import { Footer } from "../components/footer"

const IndexPage = () => (
  <Layout className="forest-page" path="forest">
    <SEO lang="ru" title="О процедурной генерации лесов" />
    <div className="lead">
      <ImageIndexLead />
      <h1>Лес</h1>
      <summary>Это история о том, как вырастить лес. В браузере.</summary>
    </div>
    <article>
      <iframe
        className="tree-on-box"
        frameBorder="0"
        src="/tree-on-cube/index.html"
      />
      <p>
        Предположим, вы хотите создать игру, действие которой происходит в лесу.
        Или же просто игру, в которой есть лесной массив. Как это сделать? Самый
        дешевый способ - сгенерировать случайное распределение деревьев по
        заданной поверхности.
      </p>
      <p>
        Однажды, когда я был за городом, я много времени провел в лесу и мне не
        давала покоя мысль: как сымитировать его случайность? В лесу все
        хаотично, но при этом взаимосвязано. Тогда я провел небольше
        исследование и нашел отличную статью Уэсли Керра{" "}
        <Link to="https://www.wesley-kerr.com/forest/">о генерации лесов</Link>.
        Я не буду делать перевод этой статьи, однако, она довольно простая и
        интересная, и она точно стоит того, чтобы ознакомиться. Или, например, с
        этими работами по{" "}
        <Link to="http://pcg.wikidot.com/pcg-algorithm:forests">
          процедурной генерации растений
        </Link>
        . Основываясь на этой работе я сделал порт кода в javascript и вот что
        из этого вышло. Результат можно увидеть в{" "}
        <Link to="https://github.com/johnSamilin/forest/blob/develop/src/utils/ForestGenerator.ts">
          репозитории
        </Link>
        .
      </p>
      <h2>Камера, мотор</h2>
      <p>
        Представим, что у нас есть уже настроенная сцена на{" "}
        <em>react-three-fiber</em>: равнина, которую предстоит засеять
        деревьями, камера и свет.
      </p>
      <p>
        Как следует из статьи, работа алгоритма имитации леса зависит от
        параметров:
        <ul>
          <li>
            n<sub>f</sub> - начальное количество деревьев.
          </li>
          <li>
            R<sub>s</sub> - радиус, внутри которого падают семена.
          </li>
          <li>
            S<sub>s</sub> - количество семян, которые падают в каждой итерации.
          </li>
          <li>
            d<sub>s</sub> - вероятность гибели семян.
          </li>
          <li>
            F<sub>c</sub> - желаемый уровень покрытия поверхности лесом.
          </li>
        </ul>
        Изначально разбрасываем по полю несколько деревьев (n<sub>f</sub>),
        затем повторяем этап роста столько раз, сколько потребуется для
        желаемого уровня покрытия. Каждый этап роста сопровождается:
        <ol>
          <li>падением семян</li>
          <li>ростом деревьем</li>
          <li>гибелью семян :(</li>
        </ol>
      </p>
      <p>
        Хорошо, алгоритм работает. И результатом его работы является матрица с
        числами от 1 до 3 и массив координат, на которых должны располагаться
        деревья. Зачем нам матрица, спросите вы. Затем, что она показывает
        проходимые (пусто) и непроходимые (дерево) области, а мы хотим знать{" "}
        <del>где сидит фазан</del> это, чтобы использовать в алгоритме{" "}
        <Link to="/pathfinding">поиска пути</Link>. Итак, что же получилось?
      </p>
      <p className="screen">
        <img src="/images/trees-close.PNG" />
      </p>
      <p>
        Выглядит не очень. Все потому, что трехмерные объекты обладают размерами
        и нужно с этим считаться. Предположим, что каждая ячейка{" "}
        <em>матрицы проходимости</em> представляет собой ячейку поверхности в
        сцене размером <strong>NxN</strong>. Тогда для того, чтобы получить
        реальные координаты дерева, нужно просто умножить их на N. Но все равно
        чего-то не хватает.
      </p>
      <h2>Точки опоры</h2>
      <p>
        Когда вы хотите расположить объект в трехмерной сцене в точке [0, 0, 0],
        где вы ожидаете его увидеть? Если это окно браузера, то, вероятно, в
        углу плоскости. <em>Нет</em>. Центр системы координат в такой сцене
        совпадает с центром плоскости, и для того, чтобы правильно разместить
        лес по поверхности, нужно вычесть из координат каждого дерева &frac14;
        ширины или длины плоскости.
      </p>
      <p>
        Теперь у нас две проблемы. Во-первых, деревья расположены так, как
        должны, за одним исключением. Часть из них, те, что растут густо,
        выстроились в ровные ряды, как будто их сажали юннаты. Во-вторых, все
        они одного возраста и роста. За возраст можно взять то количество циклов
        генерации, которое "прожило" дерево. От него может зависеть его рост и
        количество падающих семян (S<sub>s</sub>). Это не совсем то, чего
        ожидаешь от дикой природы, так что давайте добавим в{" "}
        <em>случайное распределение</em> элемент случайности.
      </p>
      <div className="compare">
        <p className="screen">
          <img src="/images/trees-translated.PNG" />
        </p>
        <ReactRough
          width={110}
          height={160}
          config={{
            options: {
              roughness: 2,
            },
          }}
        >
          <Curve
            points={[
              [50, 0],
              [100, 20],
              [20, 100],
              [50, 150],
            ]}
            stroke="red"
          />
          <Line x1={50} x2={50} y1={125} y2={150} stroke="red" />
          <Line x1={50} x2={30} y1={150} y2={150} stroke="red" />
        </ReactRough>
        <p className="screen">
          <img src="/images/trees-final.PNG" />
        </p>
      </div>
      <p>И получим вполне реалистичный лес.</p>
      <p className="date">1 июля 2020</p>
      <Footer />
    </article>
  </Layout>
)

export default IndexPage
