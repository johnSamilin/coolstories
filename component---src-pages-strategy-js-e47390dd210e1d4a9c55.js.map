{"version":3,"sources":["webpack:///./src/pages/strategy.js"],"names":["Page","className","path","lang","title","brackets","show","type","roughness","color","id","width","height","renderer","d","stroke","to","class","loading","src","alt"],"mappings":"4FAAA,iJA6QeA,UAhQF,kBACX,kBAAC,IAAD,CAAQC,UAAU,gBAAgBC,KAAK,YACrC,kBAAC,IAAD,CAAKC,KAAK,KAAKC,MAAM,yBACrB,4BAAQH,UAAU,QAChB,iDACA,6PAOF,kBAAC,IAAD,CACEI,SAAS,SACTC,MAAI,EACJC,KAAK,UACLC,UAAW,EACXC,MAAM,OAEN,iCACE,mOAKE,yBAAKC,GAAG,qBACN,kBAAC,IAAD,CAAYC,MAAO,IAAKC,OAAQ,IAAKC,SAAS,OAC5C,kBAAC,IAAD,CACEL,UAAW,EACXM,EAAE,0bAEJ,kBAAC,IAAD,CACEC,OAAO,QACPD,EAAE,gQAEJ,kBAAC,IAAD,CACEC,OAAO,QACPD,EAAE,mDAEJ,kBAAC,IAAD,CACEC,OAAO,MACPD,EAAE,oFAEJ,kBAAC,IAAD,CACEC,OAAO,MACPD,EAAE,qFAEJ,kBAAC,IAAD,CACEC,OAAO,MACPD,EAAE,qFAEJ,kBAAC,IAAD,CACEC,OAAO,MACPD,EAAE,mFAEJ,kBAAC,IAAD,CACEC,OAAO,MACPD,EAAE,mFAEJ,kBAAC,IAAD,CACEC,OAAO,mBACPD,EAAE,sHAzCV,oVAmDE,6BACA,6BApDF,2RA0DE,kBAAC,OAAD,CAAME,GAAG,iDAAT,sCA1DF,kSAmEA,+SAKS,IACP,kBAAC,OAAD,CAAMA,GAAG,yDAAT,SANF,obAgBE,kBAAC,OAAD,CAAMA,GAAG,iKAAT,qCAMN,yBAAKC,MAAM,eACT,yBACEC,QAAQ,OACRC,IAAI,sBACJC,IAAI,2BAEN,yBAAKnB,UAAU,QACb,kBAAC,IAAD,CAAWA,UAAU,cAEjB,mrBAkCN,yBACEiB,QAAQ,OACRC,IAAI,uBACJC,IAAI,0BAGR,kBAAC,IAAD,CACEf,SAAU,CAAC,MAAO,UAClBC,MAAI,EACJC,KAAK,UACLC,UAAW,EACXC,MAAM,OAEN,iCACE,oEACyC,IACvC,kBAAC,OAAD,CAAMO,GAAG,+CAAT,oDAEQ,IAJV,wEAKwE,IACtE,kBAAC,OAAD,CAAMA,GAAG,kKAAT,gCANF,IAUE,6BACA,6BAXF,ypBAsBE,yBAAKf,UAAU,QACb,kBAAC,IAAD,CAAWA,UAAU,cAEjB,+vBAzBR,wSAyDE,6BACA,6BA1DF,wTAgEE,6BACA,6BAjEF,KAiEU,kBAAC,OAAD,CAAMe,GAAG,kBAAT,cAjEV,uIAsEA,yBAAKf,UAAU,QAAf,mBACA,kBAAC,IAAD,QAGJ,yBAAKgB,MAAM,eACT,yBACEC,QAAQ,OACRC,IAAI,2BACJC,IAAI,gCAEN,yBACEF,QAAQ,OACRC,IAAI,wBACJC,IAAI,yBAEN,yBAAKF,QAAQ,OAAOC,IAAI,qBAAqBC,IAAI","file":"component---src-pages-strategy-js-e47390dd210e1d4a9c55.js","sourcesContent":["import React from \"react\"\nimport { Link } from \"gatsby\"\nimport ReactRough, { Path } from \"react-rough\"\nimport { RoughNotation } from \"react-rough-notation\"\nimport Highlight from \"react-highlight\"\n\nimport Layout from \"../components/layout\"\nimport SEO from \"../components/seo\"\nimport { Footer } from \"../components/footer\"\n\nimport \"./strategy.css\"\nimport \"highlight.js/styles/Hybrid.css\"\n\nconst Page = () => (\n  <Layout className=\"strategy-page\" path=\"strategy\">\n    <SEO lang=\"ru\" title=\"Об управлении толпой\" />\n    <header className=\"lead\">\n      <h1>Управление толпой</h1>\n      <summary>\n        Забавная штука - разработка игр. Самые базовые механики в ней могут\n        вызвать (и, несомненно, вызовут) затруднения у меня, как у\n        frontend-разработчика, привыкшего думать другими категориями и\n        архитектурными шаблонами.\n      </summary>\n    </header>\n    <RoughNotation\n      brackets=\"bottom\"\n      show\n      type=\"bracket\"\n      roughness={1}\n      color=\"red\"\n    >\n      <article>\n        <p>\n          К&nbsp;примеру, как передвигать модель персонажа и при этом\n          синхронизировать его перемещение с анимацией ходьбы, чтобы опорная\n          нога не скользила по поверхности, а оставалась на месте до следующего\n          шага?\n          <div id=\"path-illustration\">\n            <ReactRough width={720} height={600} renderer=\"svg\">\n              <Path\n                roughness={1}\n                d=\"M656.548,228.571C630.357,228.571 629.167,253.571 630.357,254.762C631.548,255.952 629.167,271.429 649.405,276.19C669.643,280.952 682.738,270.238 685.119,255.952C687.5,241.667 638.69,189.286 660.119,309.524C681.548,429.762 714.881,380.952 681.548,390.476C648.214,400 696.7,412.502 669.481,350.299C642.262,288.095 536.31,310.714 672.024,309.524C807.738,308.333 700.595,307.143 724.405,309.524C748.214,311.905 649.081,304.169 669.481,350.299\"\n              />\n              <Path\n                stroke=\"black\"\n                d=\"M684.935,407.755C684.935,407.755 655.983,506.04 588.173,508.326C520.364,510.612 447.221,378.802 454.84,392.516C462.459,406.231 396.174,275.945 298.65,367.374C201.126,458.802 188.174,230.993 185.888,212.707C183.602,194.421 195.793,8.517 340.555,130.421\"\n              />\n              <Path\n                stroke=\"black\"\n                d=\"M329.507,130.97L340.851,130.97L340.851,120.744\"\n              />\n              <Path\n                stroke=\"red\"\n                d=\"M604.173,487.755L626.269,509.85L616.364,499.945L632.364,483.945L603.411,512.897\"\n              />\n              <Path\n                stroke=\"red\"\n                d=\"M466.269,430.612L501.316,430.612L484.554,430.612L484.554,415.374L484.554,445.088\"\n              />\n              <Path\n                stroke=\"red\"\n                d=\"M364.935,320.897L395.412,351.374L379.924,335.886L394.417,321.393L366.081,349.729\"\n              />\n              <Path\n                stroke=\"red\"\n                d=\"M244.371,375.819L269.836,401.284L257.478,388.926L270.71,375.694L245.494,400.91\"\n              />\n              <Path\n                stroke=\"red\"\n                d=\"M171.969,203.303L201.429,203.303L185.95,203.303L182.455,190.57L190.195,212.541\"\n              />\n              <Path\n                stroke=\"rgb(235,235,235)\"\n                d=\"M683.976,407.675L617.538,500.322L484.662,432.056L379.824,336.97L259.139,388.779L185.996,204.094L340.815,130.342\"\n              />\n            </ReactRough>\n          </div>\n          &nbsp;Вроде есть путь, по которому его нужно провести, сама модель и\n          ландшафт. &nbsp;Но только как ориентировать его в нужную сторону? Если\n          бы он направлялся по прямой, &nbsp;то можно было бы просто\n          ориентировать его в сторону конечной точки. Но ведь путь - это ломаная\n          кривая, так что по пути от одной точки до другой в таком случае он\n          ходил бы боком.\n          <br />\n          <br />\n          Можно предположить, что, когда он достигнет одной опорной точки,\n          достаточно повернуть модель в сторону следующей опорной точки. Но и\n          это не даст нужного эффекта: персонаж будет разворачиваться слишком\n          резко. После долгих экспериментов и поиска решений я остановился на\n          следующем (\n          <Link to=\"https://github.com/mrdoob/three.js/issues/743\">\n            How to move objects along a spline\n          </Link>\n          ): от начальной до конечной точки можно нарисовать кривую Безье,\n          заставить персонажа двигаться по ней и смотреть себе под ноги, то есть\n          быть направленным в следующую точку кривой. Так получится плавный\n          проход по всем звеньям маршрута (с багами в некоторых случаях, но не\n          будем об этом).\n        </p>\n        <p>\n          Победа! Но есть одно \"но\". Анимации в Three.js не проигрываются сами\n          по себе, даже будучи запущенными внутри игрового цикла. Их нужно\n          проводить самому, мол, любезная анимация, давай сделаем вид, что ты\n          уже в точке 15%. И для этого обычно используется вспомогательный\n          объект{\" \"}\n          <Link to=\"https://threejs.org/docs/index.html#api/en/core/Clock\">\n            Clock\n          </Link>\n          . \"Но\" заключается в том, что он приостанавливает стрелки, если\n          ресурсов не хватает. Так что вертеть камерой в момент передвижения не\n          получится. Это несомненно полезно для анимации каких-то второстепенных\n          моделей, частотой обновления которых можно пожертвовать для\n          производительности, но не для модели игрока. Для того, чтобы сделать\n          задачу продвижения анимации супер-приоритетной, пришлось вынести эту\n          логику внутрь web worker'а. &nbsp;\n          <Link to=\"https://github.com/johnSamilin/forest/commit/c272188c5fb6c7f17a223df6067b68c07c690c50#diff-7ab582f544ca56c9375ffb3cb4e7e8cbeb3dca29aabe63205f81e34c415f56c1R1\">\n            Анимация перемещения по кривой\n          </Link>\n        </p>\n      </article>\n    </RoughNotation>\n    <div class=\"gif-wrapper\">\n      <img\n        loading=\"lazy\"\n        src=\"images/useFrame.gif\"\n        alt=\"Перемещение без worker\"\n      />\n      <div className=\"code\">\n        <Highlight className=\"javascript\">\n          {\n            \"const ctx: Worker = self as any;\\n \\\n\\n \\\nlet lastTime: number;\\n \\\nlet scheduleNextCall = true;\\n \\\n\\n \\\nfunction tick() {\\n \\\n  const currentTime = performance.now();\\n \\\n  ctx.postMessage({\\n \\\n    useFrame: {\\n \\\n      delta: (currentTime - lastTime) / 1000, // in seconds\\n \\\n    },\\n \\\n  });\\n \\\n  lastTime = currentTime;\\n \\\n  if (scheduleNextCall) {\\n \\\n    requestAnimationFrame(tick);\\n \\\n  }\\n \\\n}\\n \\\n\\n \\\n// Respond to message from parent thread\\n \\\nctx.addEventListener('message', (e) => {\\n \\\n  if (!e.data.useFrame) {\\n \\\n    return;\\n \\\n  }\\n \\\n  if (e.data.useFrame.enabled) {\\n \\\n    scheduleNextCall = true;\\n \\\n    lastTime = performance.now();\\n \\\n    tick();\\n \\\n  } else {\\n \\\n    scheduleNextCall = false;\\n \\\n  }\\n \\\n});\"\n          }\n        </Highlight>\n      </div>\n      <img\n        loading=\"lazy\"\n        src=\"images/useWorker.gif\"\n        alt=\"Перемещение с worker\"\n      />\n    </div>\n    <RoughNotation\n      brackets={[\"top\", \"bottom\"]}\n      show\n      type=\"bracket\"\n      roughness={1}\n      color=\"red\"\n    >\n      <article>\n        <p>\n          Как говорилось в одном хорошем фильме,{\" \"}\n          <Link to=\"https://www.youtube.com/watch?v=X1XQe3wwPmo\">\n            Трудно с тремя, а потом число не имеет значения!\n          </Link>{\" \"}\n          Управлять одним персонажем мне показалось занятием скучным, поэтому я{\" \"}\n          <Link to=\"https://github.com/johnSamilin/forest/commit/f088c3b76a487ca26f0b4d96dca636b73b354da3#diff-3d74dddefb6e35fbffe3c76ec0712d5c416352d9449e2fcc8210a9dee57dff67R52\">\n            решил добавить еще несколько\n          </Link>\n          .\n          <br />\n          <br />\n          Архитектура react диктует императивный подход к управлению: когда\n          компонент, представляющий игрока, получает новый путь, то он, как\n          истинный самурай, реагирует запуском анимаций и передвижением по нему.\n          Это свойство передает ему родительский компонент, так что, если в\n          момент передвижения одной фигурки задать маршрут для другой, то все\n          сразу сломается. Думаю, в нормальных движках с ООП-подходом такие вещи\n          разрешаются легко и просто, но в проекте, где используется\n          react-three-fiber, нужно исходить из принятых шаблонов. И самым\n          логичным было бы выделение общего менеджера, который бы управлял NPC,\n          как кукловод. На роль такого менеджера неплохо подошел Redux.\n          <div className=\"code\">\n            <Highlight className=\"javascript\">\n              {\n                \"const [activePlayer, setActivePlayer] = useState('oldman');\\n \\\n                \\n \\\nconst [playersState, dispatch] = useReducer(playersReducer, {\\n \\\n  movement: playerIds.reduce((acc, id) => ({ ...acc, [id]: null }), {}),\\n \\\n  position: playerIds.reduce((acc, id, index) => ({ ...acc, [id]: [25 + index, 0, 25 + index] }), {}),\\n \\\n});\\n \\\n\\n \\\nfunction handleFloorClick(e) {\\n \\\n  e.stopPropagation();\\n \\\n  if (isWorkerBusy) {\\n \\\n    return;\\n \\\n  }\\n \\\n  dispatch(movePlayer(activePlayer, path));\\n \\\n}\\n \\\n\\n \\\n<Context.Provider value={{ dispatch, playersState }}> \\n \\\n  {playerIds.map((id) => <Character \\n \\\n    id={id} \\n \\\n    position={playersState.position[id]} \\n \\\n    model=\\\"player/Manequin\\\" \\n \\\n    isSelected={activePlayer === id} \\n \\\n  />)} \\n \\\n</Context.Provider>\\\n                \"\n              }\n            </Highlight>\n          </div>\n          Так контроллер игры будет искать путь и сообщать его выбранному юниту,\n          а тот, в свою очередь, уведомлять контроллер о том, что он достиг\n          точки назначения. Чтобы, например, обновить информацию о том, какие\n          клетки поверхности проходимы, а какие - нет, чтобы юниты не проходили\n          сквозь друг друга.\n          <br />\n          <br />\n          Ну и наконец, когда по отдельности каждый NPC ходит своей дорогой,\n          стоит научить их ходить всем вместе. Для этого всего лишь нужно искать\n          путь для каждого выбранного персонажа по отдельности в тот момент,\n          когда выбран конечный пункт и есть уверенность в том, что его можно\n          достигнуть хотя бы одним персонажем.\n          <br />\n          <br />В <Link to=\"/strategy-demo\">демо-сцене</Link> можно попробовать,\n          как это все работает. Выбрать нескольких персонажей можно зажав левый\n          shift (либо рамкой, либо по отдельности).\n        </p>\n\n        <div className=\"date\">21 февраля 2021</div>\n        <Footer />\n      </article>\n    </RoughNotation>\n    <div class=\"gif-wrapper\">\n      <img\n        loading=\"lazy\"\n        src=\"images/separate-walk.gif\"\n        alt=\"Передвижение по отдельности\"\n      />\n      <img\n        loading=\"lazy\"\n        src=\"images/group-walk.gif\"\n        alt=\"Передвижение группой\"\n      />\n      <img loading=\"lazy\" src=\"images/bracket.gif\" alt=\"Выделение группы\" />\n    </div>\n  </Layout>\n)\n\nexport default Page\n"],"sourceRoot":""}